#!env python

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import time
import argparse
import codecs
import cPickle as pickle
import csv
import datetime
import os
import shutil
import glob
import scipy.interpolate
import json
from matplotlib.patches import Rectangle
from collections import OrderedDict

from cmd import Cmd
import sys
sys.path.insert(0, "/home/eetakala/git/textemplator/")

from textemplator import TexTemplator

plt.rcParams.update({'font.size':20})
plt.rcParams.update({'lines.markersize':20})
plt.rcParams.update({'legend.numpoints':1})
note_x_rel_pos = 0.75
linewidth = 3
print_parameters_and_dwells_calls = 0

TO_MATH_DICT = {
        'Target\_T':'Target [$^\circ$C]',
        'Allowed\_Band':'Allowed Band [$^\circ$C]',
        'duration':'$\Delta t$ [h]',
        'Tmaxmax_prec':'$\max{T_\mathrm{prec}}$ [$^\circ$C]',
        'Tmaxmax':'$\max{T}$ [$^\circ$C]',
        'Tminmin':'$\min{T}$ [$^\circ$C]',
        'Hmax/2':'$\max{H/2}$ [$^\circ$C]',
        'Tmaxmean':'$\mean{\max{T}}$ [$^\circ$C]',
        'Tmidmean':'$\mean{\mid{T}}$ [$^\circ$C]',
        'Tmid':'$\midrange{T}$ [$^\circ$C]',
        'Tminmean':'$\mean{\min{T}}$ [$^\circ$C]',
        'Hmean/2':'$\mean{H/2}$ [$^\circ$C]',
        'Hasmax/2':'$\max{H_\mathrm{asm}/2}$ [$^\circ$C]',
        'Hasmean/2':'$\mean{H_\mathrm{asm}/2}$ [$^\circ$C]'
}

def to_math(string):
    out = string
    for key in TO_MATH_DICT:
        out = out.replace(key, TO_MATH_DICT[key])
    return out

def fix_units(unit):
    fixed_unit = ''
    for char in unit:
        c = char
        if ord(char) == 176: c ='$^\circ$'
        fixed_unit += c
    return fixed_unit

def latex_table_fix_units(latex_table, program, program_keys):
    for i, program_key in enumerate(program_keys):
        unit = get_variable_unit(program_key, program['variables'], program['units'])
        fixed_unit = fix_units(unit)
        try:
            latex_table = latex_table.replace(program_key, program_key + ' [' + fixed_unit + ']')
        except:
            latex_table = latex_table.replace(program_key, program_key + ' [' + unit + ']')
    return latex_table

def get_variable_unit(variable, variables, units):
    for i, cmp_variable in enumerate(variables):
        if cmp_variable == variable:
            return units[i]
    return None

class Report(TexTemplator):

    def __init__(self, path, template_path):
        TexTemplator.__init__(self, path, template_path)
        self.tables={}
        self.figures={}
        self.temp_image_paths = []

    def store_table(self, table, label, caption=None, resize_textwidth=False):
        self.tables[label] = self.table(table, label, caption, resize_textwidth)

    def store_figure(self, path, label, caption=None):
        self.figures[label] = self.figure(path, label, caption)

    def compare_analyses(self, RHTdata, args):
        RHTdatas=[]
        dwell_tables = []
        print "Compare with previously analyzed data."
        print "We need to load all the existing RHTdata pickles."
        basename = os.path.splitext(RHTdata['path'])[0]
        pickle_path = basename +'_analyzed.pickle'
	if os.path.isfile(pickle_path):
            print "There is an old pickle file for", basename, "analysis, I'm deleting it..."
            os.remove(pickle_path)
        for filepath in glob.glob('*analyzed.pickle'):
            print "Loading: ", filepath
            RHTdatas.append(cpickle_load(filepath))

        if len(RHTdatas) > 0:
            RHTdatas.append(RHTdata)
            print "RHTdatas:", [R['path'] for R in RHTdatas]
            for RHTdata in RHTdatas:
                RHTdata['datestr'] = ''.join([w for w in reversed(RHTdata['date'].split('.'))]) 
            RHTdatas = sorted(RHTdatas, key = lambda i: i['datestr'])
            for i, RHTdata in enumerate(RHTdatas):
                if i>0:
                    summary_df = summary_df.append(RHTdata['summary_df'])
                else:
                    summary_df = RHTdatas[0]['summary_df']

            summary_dwell_grouped = summary_df.groupby('Dwell')
            dwell_numbers = summary_dwell_grouped.groups.keys()
            #tex_cols = ['Coil ID', 'duration', 'Target_T', 'Allowed_Band', 'Tmaxmax_prec', 'Tmaxmax', 'Tmid', 'Tminmin', 'Hmax/2', 'Tmaxmean','Tmidmean', 'Tminmean', 'Hmean/2', 'Hasmax/2','Hasmean/2']
            tex_cols = ['Coil ID', 'duration', 'Target_T', 'Allowed_Band', 'Tmaxmax_prec', 'Tmaxmax', 'Tminmin', 'Hmax/2', 'Hasmax/2', 'Tmaxmean', 'Tmidmean','Tminmean', 'Hmean/2','Hasmean/2']
            summary_cols = tex_cols
            #summary_cols = ['File', 'duration', 'Target_T', 'Tmaxmax', 'Tmeanmean', 'Hmax/2', 'Hasmax/2']
            #print_params['Tmid'].append(dwell['Tmid'])
            #print_params['Tmid_dev'].append(dwell['Tmid dev'])
            #print_params['Tmidmean'].append(dwell['Tmidmean'])
            #print_params['Tmidmean_dev'].append(dwell['Tmidmean dev'])
            #print_params['Tmeanmid'].append(dwell['Tmeanmid'])
            #print_params['Tmeanmid_dev'].append(dwell['Tmeanmid dev'])
            #print_params[].append(dwell['Hmax/2'])
            #print_params['Hmean/2'].append(dwell['Hmean/2'])
            #print_params[].append(dwell['Hasmax/2'])
            #print_params['Hasmin/2'].append(dwell['Hasmin/2'])
            #print_params['Hasmean/2'].append(dwell['Hasmean/2'])

            for n in dwell_numbers:
                dwell_summary_df = summary_dwell_grouped.get_group(n).dropna().round(decimals=1)
                self.store_table(to_math(dwell_summary_df[summary_cols].to_latex(index=False, header=True, float_format="{:0.1f}".format)).replace('CR110','\\hline \nCR110'), 'table:dwell ' + str(n) + ' summary', caption='Dwell ' + str(n) + ' comparison summary for all analyzed files.', resize_textwidth=True)
                plot_dwell_summary(RHTdatas, n, args)
            
            plot_TC_IT_summary(RHTdatas, args)


        else: 
            print "I didn't find any previous analyzed RHTdata pickles. No point in doing a summary."
            
    def write_remarks(self, RHTdata, itemized_remarks):
        remarks=''
        dwell_remarks='\n'
        overshoots = []
        belows = []
        homogovers = []
        durations = []
        temperature_resolution = 0.1
        for dwell in RHTdata['dwells']:
            dwell_df = dwell['DataFrame']
            n = dwell['n']
            durnoms = [48., 48., 50.]
            durnom = durnoms[n-1]
            allowed = dwell['target_ranges'][n-1]
            if round(dwell['Tmaxmax'], 1) > allowed[1] + temperature_resolution: 
                overshoot = dwell['Tmaxmax'] - allowed[1]
                overshoots.append((n,overshoot,dwell['Tmaxmax'],allowed[1]))
                #dwell_remarks+='Absolute maximum temperature during dwell ' + str(n) + ' is {:0.1f}'.format(overshoot) + ' $\degC$ higher than allowed.\n'
            if round(dwell['Tminmin'], 1) < allowed[0] - temperature_resolution: 
                below = allowed[0] - dwell['Tminmin'] 
                belows.append((n,below,dwell['Tminmin'],allowed[0]))
                #dwell_remarks+='Absolute minimum temperature during dwell ' + str(n) + ' is {:0.1f}'.format(below) + ' $\degC$ lower than allowed.\n'
            if round(dwell['Hmean/2'], 1) > 3.:
                over = dwell['Hmean/2']
                homogovers.append((n,over,dwell['Hmean/2'],3.))
            durations.append((n, dwell['duration']-durnom))

        if len(overshoots) > 0:
            dwell_remarks+="\item Absolute maximum temperature has violated the allowed band condition during dwells: " + ', '.join(['{} ({:0.1f} $\degC >$ {:0.1f} $\degC$)'.format(shoot[0], shoot[2], shoot[3]) for shoot in overshoots]) + ".\n"
        if len(belows) > 0:
            dwell_remarks+="\item Absolute minimum temperature has violated the allowed band condition during dwells: " + ', '.join(['{} ({:0.1f} $\degC <$ {:0.1f} $\degC$)'.format(below[0], below[2], below[3]) for below in belows]) + ".\n"
        if len(homogovers) > 0:
            dwell_remarks+="\item The mean homogeneity has violated the allowed condition during dwells: " + ', '.join(['{} ({:0.1f} $\degC >$ {:0.1f} $\degC$)'.format(over[0], over[2], over[3]) for over in homogovers]) + ".\n"

        dwell_remarks+="\item The dwell durations w.r.t. nominal: " + ', '.join(['{}. {:0.1f} h'.format(dt[0],dt[1]) for dt in durations]) + ".\n"


        if not '\item' in dwell_remarks:
            remarks = ''
        else:
            remarks = '\\begin{itemize}\n'
            remarks += itemized_remarks
            remarks += dwell_remarks
            remarks += '\\end{itemize}\n'

        return remarks

    def write_report(self, RHTdata):
        self.doc_data = {}

        with open(RHTdata['basename'] + '.json') as json_file:
            self.doc_data = json.load(json_file)
        #try:
            #with open(RHTdata['basename'] + '.json') as json_file:
                #self.doc_data = json.load(json_file)
        #except:
            #print RHTdata['basename'] + '.json loading failed! Cannot create the report!'

        if 'mapping_picture_file' in self.doc_data:
            mapping_picture_file = self.doc_data['mapping_picture_file']
        else:
            mapping_picture_file = 'png/Default_mapping.png'

        d = {}
        for key in self.doc_data:
            if '%' in key:
                d[key] = self.doc_data[key]

        d['%FIG_DEFAULT_MAPPING'] = self.figure(mapping_picture_file, 'fig:default_mapping', caption='The thermo-couple locations. Those that are marked with a blue, yellow or red (if any) X are not included in the analysis. Blue represents argon temperature, yellow represents end plate temperature and red represents rejected based on careful examination.')
        
        if "%CSV_files" not in d: d['%CSV_files'] = "-"
        if "%RHT_CYCLE_EDMS" not in d: d['%RHT_CYCLE_EDMS'] = "2270203"
        param_table_keys = ['Start date', 'End date', 'Furnace', 'Cable type', 'CSV file']
        param_table = OrderedDict({'Start date': [RHTdata['start date']],
                     'End date': [RHTdata['end date']],
                     'Furnace': ['Gero GLO 10000KE/09-1'],
                     'Cable type': [d['%CABLE_ID'] + ' (' + d['%STRAND_TYPE']+ ')'],
                     'CSV file': [d['%CSV_files']]})

        d['%FIG_DWELL_PLOT'] = self.figures['fig:dwell_plot']
        d['%FIG_HEATING_RATE'] = self.figures['fig:heating_rate']
        d['%FIG_HOMOGENITY'] = self.figures['fig:homogeneity']
        d['%FIG_MIDDEVT_DWELLS'] = self.figures['fig:middevT_dwells-map']
        d['%FIG_BLOCK_HOMOGENITY_DWELLS'] = self.figures['fig:block_homogeneity_dwells-map']

        d['%TAB_PARAM'] = self.table(to_math(pd.DataFrame(param_table)[param_table_keys].transpose().to_latex(header=False)), 'table:data', caption='General RHT parameters')
        d['%TAB_SUMMARY'] = self.tables['table:summary']
        if not '%REMARKS' in d: 
            itemized_remarks = ''
        else:
            itemized_remarks = '\item ' + '\item \n'.join(d['%REMARKS'])
        d['%REMARKS'] = self.write_remarks(RHTdata, itemized_remarks)
        

        # RHT program
        program_keys = [key for key in RHTdata['program']['variables'] if (RHTdata['program']['DataFrame'][key] != 0).any()]
        non_step_keys = list(program_keys)
        if 'Step' in non_step_keys: non_step_keys.remove('Step')
        col_format = "".join(['|p{1.3cm}' for key in program_keys]) + '|'
        df = RHTdata['program']['DataFrame']
        df = df[(df[non_step_keys].T != 0).any()]
        df['Step'] = df.index+1
        latex_table = self.table(df[program_keys].to_latex(index=False, float_format="{:3.0f}".format, column_format=col_format), 'table:program', caption='The RHT program for the furnace. Only columns with any non-zero values are presented ', resize_textwidth=True)

        latex_table = latex_table_fix_units(latex_table, RHTdata['program'], program_keys)
        d['%RHT_PROGRAM'] = latex_table

        online_tables = []
        for i, online in enumerate(RHTdata['onlines']):
            program_keys = [key for key in online['variables'] if (online['DataFrame'][key] != 0).any()]
            if 'Step' in non_step_keys: non_step_keys.remove('Step')
            col_format = "".join(['|p{1.3cm}' for key in program_keys]) + '|'
            df = online['DataFrame']
            df = df[(df[non_step_keys].T != 0).any()]
            latex_table = self.table(df[program_keys].to_latex(index=False, float_format="{:3.0f}".format, column_format=col_format), 'table:online_'+str(i+1), caption='The RHT online change '+str(i+1)+'.', resize_textwidth=True)
            latex_table = latex_table_fix_units(latex_table, online, program_keys)
            online_tables += [latex_table]
        d['%RHT_ONLINES'] = "\n".join(online_tables)


        for i in range(1,4):
            try:
                d['%TAB_DWELL_' + str(i) + '_SUMMARY'] = self.tables['table:dwell ' + str(i) + ' summary']
            except:
                pass

        for i in range(1,4):
            try:
                d['%FIG_BOXPLOT_DWELL_' + str(i)] = self.figures['fig:boxplot dwell ' + str(i)]
            except:
                pass

        for i in range(1,4):
            try:
                boxplottabledata = self.tables['table:dwell boxplot data ' + str(i)]
                d['%TAB_DWELL_BOXPLOT_DATA_' + str(i)] = boxplottabledata
            except:
                pass

        report.write(d)

    def compile_report(self):
        cmd = 'pdflatex ' + self.report_path
        print "Compiling report with pdflatex: ", cmd
        os.system(cmd)
        print "Removing all the temporary files."
        #for temp_image_path in self.temp_image_paths:
            #os.remove(temp_image_path)
            
class Logger:

    def __init__(self, path):
        self.logfile = open(path+'.RHT.log','w')
        self.texfile = open(path+'.RHT.tex','w')
        self.texfile.write('\\documentclass{report}\n')
        self.texfile.write('\\usepackage{booktabs}\n')
        #self.texfile.write('\\usepackage{geometry}\n')
        self.texfile.write('\\pagenumbering{gobble}\n')
        self.texfile.write('\\begin{document}\n')
        
    def write(self, line):
        print line
        self.logfile.write(line + '\n')

    def write_table(self, table):
        self.texfile.write(table)

    def close(self):
        self.logfile.close()
        self.texfile.write('\end{document}\n')
        self.texfile.close()

class Plotter:

    def __init__(self):
        self.reset()
        self.colors = ['r','g','b','k','c','y','m']
        self.markers = ['o', '^', 'v', '<', '>', 's', 'p', '*', 'h', 'd', '1', '2', '3', '4']
        self.lg_extra_text = None

    def insert_color(self, color):
        self.colors.insert(self.plot_counter+1, color)

    def reset(self):
        self.clear()
        self.fig_counter = 0

    def clear(self, figsize=(35,10)):
        self.lg_extra_text = None
        self.plot_counter = 0
        plt.close("all")
        self.fig = plt.figure(figsize=figsize)
        self.ax = self.fig.add_subplot(111)
        self.ax.autoscale(enable=True, axis='y', tight=True)
        self.ax.set_zorder(11)
        self.ax2 = None
        #self.ax.patch.set_visible(False)
        self.plots = []

    def set_lim_args(self, args):
        if args != None:
            if args.xlim != None: 
                self.ax.set_xlim(args.xlim)
            if args.ylim != None: 
                self.ax.set_ylim(args.ylim)

    def set_ylim(self, ylim):
        self.ax.set_ylim(ylim)

    def get_ylim(self, *args, **kwargs):
        return self.ax.get_ylim(*args, **kwargs)

    def set_xticks(self, *args, **kwargs):
        return self.ax.set_xticks(*args, **kwargs)

    def set_xticklabels(self, *args, **kwargs):
        return self.ax.set_xticklabels(*args, **kwargs)

    def savefig(self, fig_filename, label, suffix = '', args=None, caption=None):
        self.fig_counter += 1
        fig_filename_fixed = fig_filename.replace('.','_') + '_IMG' + str(self.fig_counter).zfill(2) + suffix
        print "Saving", fig_filename_fixed
        if hasattr(self, 'ldg') and self.lgd != None:
            plt.savefig(fig_filename_fixed, bbox_extra_artists=(self.lgd,), bbox_inches='tight')
        else:
            plt.savefig(fig_filename_fixed, bbox_inches='tight')
        report.store_figure(fig_filename_fixed, label, caption)
        self.clear()

    def set_xlabel(self, label):
        self.ax.set_xlabel(label)

    def set_ylabel(self, label):
        self.ax.set_ylabel(label)

    def set_zlabel(self, label):
        self.ax.set_zlabel(label)

    def set_ylabel2(self, label):
        self.ax2.set_ylabel(label)

    def set_ax2(self):
        self.ax2 = self.ax.twinx()
        self.ax2.set_zorder(12)

    def show(self, args=None):
        plt.show()
        self.clear()

    def annotate(self, *args, **kwargs):
        plt.annotate(*args, **kwargs)

    def get_color(self):
        return self.colors[self.plot_counter%len(self.colors)]

    def get_marker(self):
        return self.markers[self.plot_counter%len(self.markers)]

    def plot_ax(self, *args, **kwargs):
        self.plot_counter += 1
        kwargs['color'] = self.get_color()
        kwargs['linewidth'] = linewidth
        self.plots += self.ax.plot(*args, **kwargs)

    def plot_ax2(self, *args, **kwargs):
        self.plot_counter += 1
        kwargs['color'] = self.get_color()
        kwargs['linewidth'] = linewidth
        self.plots += self.ax2.plot(*args, **kwargs)

    def pcolormesh(self, *args, **kwargs):
        hours_samples = args[0]
        block_samples = args[1]
        if 'colorbar_label' in kwargs:
            colorbar_label = kwargs['colorbar_label']
            del kwargs['colorbar_label']
        else:
            colorbar_label = None
        self.plot_counter += 1
        self.plots += [self.ax.pcolormesh(*args, **kwargs)]
        plot = self.plots[-1]
        #self.ax.axis([hours_samples.min(), hours_samples.max(), block_samples.min(), block_samples.max()])
        if colorbar_label != None:
            self.fig.colorbar(plot, ax=self.ax, label=colorbar_label)

    def axvline(self, x, text=''):
        self.ax.axvline(x=x, color='black', linestyle='solid')

    def boxplot(self, *args, **kwargs):
        self.plot_counter += 1
        self.plots += [self.ax.boxplot(*args, **kwargs)]
        plot = self.plots[-1]
        #self.ax.axis([hours_samples.min(), hours_samples.max(), block_samples.min(), block_samples.max()])

    def legend(self, *args, **kwargs):
        self.plot_labels = [ax.get_label() for ax in self.plots]
        if self.lg_extra_text != None:
            self.plot_labels += self.lg_extra_text
            self.plots.append(Rectangle((0,0), 1, 1, fc='w', fill = False, edgecolor = 'none', linewidth=0))
        if self.ax2 == None:
            self.lgd = self.ax.legend(self.plots, self.plot_labels, **kwargs)
        else:
            self.lgd = self.ax2.legend(self.plots, self.plot_labels, **kwargs)

    def add_text_to_legend(self, text):
        self.lg_extra_text = [text]

    def text(self, *args, **kwargs):
        ax = self.ax
        if hasattr(self, 'ax2') and self.ax2 != None:
            ax = self.ax2
        text = ax.text(*args, **kwargs)
        text.set_zorder(100)

    def rel_pos(self, xrel, coordinate='x', args=None):
        if coordinate=='x':
            xmin, xmax = self.ax.get_xlim()
        elif coordinate=='y' or coordinate=='y2':
            if hasattr(self, 'ax2') and self.ax2 != None:
                xmin, xmax = self.ax2.get_ylim()
            else:
                xmin, xmax = self.ax.get_ylim()
        else:
            print "rel_pos: unknown coordinate! Exiting..."
        x = xmin + xrel * (xmax - xmin)
        return x

    def plot_dwells(self, dwells, only_txt=False, delta_horizontal_position=5, vertical_position=0.1, no_txt=False):
        for i, dwell in enumerate(dwells):
            dwell_df = dwell['DataFrame']
            if len(dwell_df) >= 2:
                dwell_len = dwell['duration']
                dwell_Tmean = dwell['Tmeanmean']
                dwell_mean_hper2 = dwell['Hmean/2']
                #self.plot_ax(dwell_df['hours'],dwell_df['Tmean'])
                if not no_txt:
                    self.text(dwell_df['hours'].iloc[0]+delta_horizontal_position, self.rel_pos(vertical_position, 'y'), 'Dwell ' + str(dwell['n']) + ': {:2.1f}'.format(round(dwell_len,1)) + ' hours\nmean(T)={:2.1f}\n'.format(dwell_Tmean)+'mid-range(T)={:2.1f}\n'.format(dwell['Tmid'])+'mean(H/2)={:2.1f}\n'.format(dwell_mean_hper2))
                if not only_txt:
                    self.ax.axvspan(dwell_df['hours'].iloc[0], dwell_df['hours'].iloc[-1], facecolor='green', alpha=0.2)
                else:
                    self.ax.axvline(x=dwell_df['hours'].iloc[0], color='black', linestyle='solid')
                    self.ax.axvline(x=dwell_df['hours'].iloc[-1], color='black', linestyle='solid')

    def plot_allowed_band(self, dwells, only_txt=False, delta_horizontal_position=5, vertical_position=0.1):
        
        for i, dtr in enumerate(args.dwell_target_ranges):
            if not only_txt:
                self.ax.axhspan(dtr[0], dtr[1], facecolor='green', alpha=0.2)
            else:
                self.ax.axvline(x=dwell_df['hours'].iloc[0], color='black', linestyle='solid')
                self.ax.axvline(x=dwell_df['hours'].iloc[-1], color='black', linestyle='solid')


    def plot_onlines(self, RHTdata, plot_curves=True):
        logging = RHTdata['data_logging']
        logging_df = logging['DataFrame']
        program_df = RHTdata['program']['DataFrame']
        dwells = RHTdata['dwells']
        for i, online in enumerate(RHTdata['onlines']):
            online_df = online['DataFrame']
            self.text(online['activation hours'], self.rel_pos(0.8, 'y'), 'Online change ' + str(i+1) + '\nat {:2.1f}'.format(round(online['activation hours'],1)) + ' hours', rotation=90)
            self.ax.axvline(x=online['activation hours'], color='black', linestyle='dashed')
            if plot_curves:
                self.plot_ax(online_df['hours from'],online_df['From Tp zone B3'], label='Online ' + str(i+1))

    def write_dwell_notes(self, args):
        dwells_note = 'Dwells:\n'
        if args.no_target_ranges:
            if len(args.dwell_target_temperatures)>0:
                if RHTdata['duration_based_target_temperatures']:
                    dwells_note += 'program set targets '
                else:
                    dwells_note += 'user selected targets '
                dwells_note += ', '.join([format(f, "3.0f")+'$\degree$C' for f in args.dwell_target_temperatures]) + '\n'

            nc = 0
            if args.dwell_target_deviation != None:
                nc += 1
                dwells_note += '$\pm${:2.0f}$\degree$C'.format(args.dwell_target_deviation) + ' deviation '
            if args.dwell_mid_deviation != None:
                nc += 1
                if nc >1: 
                    dwells_note += ', '
                dwells_note += '$\pm${:2.0f}$\degree$C'.format(args.dwell_mid_deviation) + ' mid-range deviation\n'
            if args.dwell_target_homogeneity != None:
                nc += 1
                if nc >1: dwells_note += 'and '
                dwells_note += '{:2.0f}$\degree$C H/2'.format(args.dwell_target_homogeneity/2.)
            if nc == 1:
                dwells_note += ' criterion'
            elif nc > 1:
                dwells_note += ' criteria'
        else:
            dwells_note += 'user defined ranges:'
            for i, r in enumerate(args.dwell_target_ranges):
                dwells_note += '\nDwell {:d}: [{}, {}]'.format(i+1, *r)

        self.text(self.rel_pos(note_x_rel_pos, 'x'), self.rel_pos(0.7, 'y'), dwells_note, style='italic',
                bbox={'facecolor': 'yellow', 'alpha':0.8, 'pad': 10})

    def write_tc_notes(self, RHTdata, rejected=True):
        logging = RHTdata['data_logging']
        logging_df = logging['DataFrame']
        program_df = RHTdata['program']['DataFrame']
        dwells = RHTdata['dwells']

        if not rejected:
            if len(logging['accepted_TC_keys'])>0:
                accepted_y_keys_note = 'Accepted thermo-couples:\n' + '\n'.join(logging['accepted_TC_keys'])
                accepted_y_keys_note += '\n' + ', '.join([format(f, "3.0f")+'$\degree$C'  for f in args.temperature_deviation_filters]) + '\ndeviation filters'
         
                self.text(self.rel_pos(note_x_rel_pos, 'x'), self.rel_pos(0.25, 'y'), accepted_y_keys_note, style='italic',
                        bbox={'facecolor': 'green', 'alpha':0.8, 'pad': 10})

        else:
            if len(logging['rejected_TC_keys'])>0:
            #if False:
                rejected_y_keys_note = 'Rejected thermo-couples:\n' + '\n'.join(logging['rejected_TC_keys'])
                rejected_y_keys_note += '\n' + ', '.join([format(f, "3.0f")+'$\degree$C'  for f in args.temperature_deviation_filters]) + '\ndeviation filters'
         
                self.text(self.rel_pos(note_x_rel_pos, 'x'), self.rel_pos(0.25, 'y'), rejected_y_keys_note, style='italic',
                        bbox={'facecolor': 'red', 'alpha':0.8, 'pad': 10})

plotter = Plotter()

def timeit(func):
    def wrapper(*args, **kwargs):
        time_start = time.time()
        o=func(*args, **kwargs)
        print 'timeit: ', func.__name__, ':{0:0.2f}s'.format(time.time()-time_start)
        return o
    return wrapper

class RHT_CSV_Reader:

    def __init__(self, delimiter=';'):
        self.CSV_DELIMITER = delimiter
        self.mode('','')
        self.skip_empty_lines = False
        self.TC_mapping = None

    def set_skip_empty_lines(self):
        if not self.skip_empty_lines:
            self.skip_empty_lines = True
            print "Reader set to skip empty lines"

    def unset_skip_empty_lines(self):
        if self.skip_empty_lines:
            self.skip_empty_lines = False
            print "Reader unset skip empty lines"

    def reader_mode_is(self, mode_str):
        return self.reader_mode_str == mode_str

    def update_reader_mode_str(self):
        self.reader_mode_str = '-'.join(self.reader_mode)

    def print_changed_mode(self):
        print "Reader mode changed to:", self.reader_mode_str

    def mode_0(self, mode0):
        self.reader_mode[0] = mode0
        self.update_reader_mode_str()
        self.print_changed_mode()

    def mode_1(self, mode1):
        self.reader_mode[1] = mode1
        self.update_reader_mode_str()
        self.print_changed_mode()

    def mode(self, mode0, mode1):
        self.reader_mode = ['','']
        self.reader_mode[0] = mode0
        self.reader_mode[1] = mode1
        self.update_reader_mode_str()
        self.print_changed_mode()

    def empty(self, row): return len(row)==0 or (len(row)==2 and (row[0].strip() == '' and row[1].strip() == ''))

    def to_float_str(self, f): 
        try:
            out = f.replace(',','.')
            return out 
        except:
            return f

    def to_name(self, header_entry):
        try:
            split_str = ' ['
            if not ' [' in header_entry: 
                split_str = '['
            out = header_entry.split(split_str)[0]
            if out[0] == ' ': out = out[1:] 
            if self.TC_mapping != None:
                if 'MT' in out and 'PV' in out and 'TC' in out:
                    print "I detected a thermo-couple variable: ", out, "let's try to use mapped name.", 
                    try:
                        #TCid = str(int(out.split('-N-')[1]))
                        TCid = out.split('-N-')[1].split('.')[0]
                        out = "TC " + TCid + ": " + self.TC_mapping[TCid]
                        print out
                    except:
                        print "Mapping not found."
                        pass
            return out
        except:
            return ''

    def to_unit(self, header_entry):
        try:
            split_str = ' ['
            if not ' [' in header_entry: split_str = '['
            return header_entry.split(split_str)[1].replace(']','') 
        except:
            return ''

    def read_RHT_file(self, args, path, override_pickle=False):
        basename = os.path.splitext(path)[0]
	pickle_path = basename +'.pickle'
	if os.path.isfile(pickle_path) and not override_pickle:
		print "Found a pickle:", pickle_path, "for", basename, "using that instead."
		return cpickle_load(pickle_path)

        RHTdata = {}
        RHTdata['path'] = path
        RHTdata['Coil ID'] = RHTdata['path'].replace('.csv', '').split('_')[0]
        RHTdata['basename'] = basename
        RHTdata['program'] = {}
        RHTdata['program']['values'] = []
        RHTdata['batch_info'] = {}
        RHTdata['data_loggings'] = []
        RHTdata['data_logging'] = {}
        RHTdata['data_logging']['values'] = []
        RHTdata['leaktest'] = {}
        RHTdata['onlines'] = []

        self.TC_mapping = None
        self.TC_mapping_file = None
        if os.path.isfile(basename + ".mapping"):
            self.TC_mapping_file = basename + ".mapping"
        elif os.path.isfile(args.thermo_couple_mapping):
            self.TC_mapping_file = args.thermo_couple_mapping
        if self.TC_mapping_file != None: 
            print "I found a thermo-couple mapping in " + "'" + self.TC_mapping_file + "'" + "trying to use that..."
            try:
                self.TC_mapping = {}
                self.block_mapping = {}
                with open(self.TC_mapping_file, 'r') as TC_map_file:
                    for line in TC_map_file:
                        line = line.rstrip('\n')
                        if ":" in line:
                            line_split = line.split(":")
                            TC_location = line_split[0]
                            TCids = [s.strip() for s in line_split[1].split(",")]
                            self.block_mapping[TC_location] = TCids
                            for TCid in TCids:
                                self.TC_mapping[TCid] = TC_location
                                print "Thermo-couple id", TCid, "->", self.TC_mapping[TCid]
                RHTdata['TC_mapping'] = self.TC_mapping
                RHTdata['block_mapping'] = self.block_mapping
            except:
                print "Mapping file error! I couldn't make sense out of the mapping file. Exiting..."
                exit()
            print "Reading thermo-couple mapping worked!"

        self.reader_mode = ['','']
        with open(path) as csv_file:
            csv_reader = csv.reader(csv_file, delimiter=self.CSV_DELIMITER)
            line_count = 0
            
            for i, row in enumerate(csv_reader):
                if not self.reader_mode_is('data_logging-values'):
                    while '' in row: row.remove('')
                    while ' ' in row: row.remove(' ')
                if self.empty(row): 
                    if self.reader_mode_is('online-values'):
                        RHTdata['data_loggings'].append({})
                        latest_logging = RHTdata['data_loggings'][-1]
                        latest_logging['values'] = []
                        self.mode('data_logging','header')
                    elif not self.skip_empty_lines:
                        self.mode('','')
                else:
                    if i <= 5:
                        RHTdata[row[1].replace(':','')] = row[2]
                    elif i < 43:
                        if len(row) >= 1:
                            if row[0] == 'Program': self.mode_0('program')
                            elif row[0] == 'Step': self.mode_1('header')

                    if self.reader_mode_is('program-header'):
                        RHTdata['program']['variables'] = [self.to_name(header_entry) for header_entry in row]
                        RHTdata['program']['units'] = [self.to_unit(header_entry) for header_entry in row]
                        self.mode_1('values')
                    elif self.reader_mode_is('program-values'):
                        RHTdata['program']['values'] += [[self.to_float_str(value) for value in row]]
                    elif self.reader_mode_is('batch_info-header'):
                        RHTdata['batch_info']['variables'] = row
                        self.mode_1('values')
                    elif row[0] == 'batch:': 
                        self.mode('batch_info', 'header')
                    elif self.reader_mode_is('batch_info-values'):
                        RHTdata['batch_info']['values'] = row
                        self.mode('', '')
                    elif row[0] == 'data logging:' or self.reader_mode_is('data_logging-init'): 
                        RHTdata['data_loggings'].append({})
                        latest_logging = RHTdata['data_loggings'][-1]
                        latest_logging['values'] = []
                        self.mode('data_logging','header')
                    elif self.reader_mode_is('data_logging-header'):
                        if not 'variables' in RHTdata['data_logging'].keys():
                            RHTdata['data_logging']['variables'] = [self.to_name(header_entry) for header_entry in row]
                            RHTdata['data_logging']['units'] = [self.to_unit(header_entry) for header_entry in row]
                        latest_logging['variables'] = [self.to_name(header_entry) for header_entry in row]
                        latest_logging['units'] = [self.to_unit(header_entry) for header_entry in row]
                        self.mode_1('values')
                    elif self.reader_mode_is('data_logging-values'):
                        #if len(RHTdata['data_loggings']) == 2:
                            #print i, row
                        self.unset_skip_empty_lines()
                        #print len(row), len(RHTdata['data_logging']['variables'])
                        #if len(row) != 135: print i, row, len(row),len(RHTdata['data_logging']['variables'])
                        latest_logging['values'] += [[self.to_float_str(value) for value in row]]
                        RHTdata['data_logging']['values'] += [[self.to_float_str(value) for value in row]]
                    elif row[0] == 'Leckrate Lecktest': 
                        RHTdata['leaktest']['variables'] = row
                        self.mode('leaktest','values')
                    elif self.reader_mode_is('leaktest-values'):
                        RHTdata['leaktest']['values'] = row
                        self.mode('data_logging', 'values')
                        self.set_skip_empty_lines()
                    elif row[0] == 'online:': 
                        if len(latest_logging['values']) == 0:
                            print "No values read! Removing the latest data_logging and online change..."
                            RHTdata['data_loggings'].pop()
                            RHTdata['onlines'].pop()
                        self.mode('online','prog_header')
                    elif self.reader_mode_is('online-prog_header'):
                        RHTdata['onlines'].append({})
                        latest_online = RHTdata['onlines'][-1]
                        latest_online['variables'] = row
                        latest_online['values'] = []
                        self.mode_1('header')
                        self.set_skip_empty_lines()
                    elif self.reader_mode_is('online-header'):
                        self.unset_skip_empty_lines()
                        latest_online['variables'] = [self.to_name(header_entry) for header_entry in row]
                        latest_online['units'] = [self.to_unit(header_entry) for header_entry in row]
                        self.mode_1('values')
                        self.set_skip_empty_lines()
                    elif self.reader_mode_is('online-values'):
                        self.unset_skip_empty_lines()
                        latest_online['values'] += [[self.to_float_str(value) for value in row]]
                    
        RHTdata['program']['DataFrame'] = to_DataFrame(RHTdata['program']['variables'],RHTdata['program']['values'], args)

        RHTdata['data_logging']['DataFrame'] = to_DataFrame(RHTdata['data_logging']['variables'],RHTdata['data_logging']['values'], args)

        for i,logging in enumerate(RHTdata['data_loggings']):
            logging['DataFrame'] = to_DataFrame(logging['variables'], logging['values'], args)
        for online in RHTdata['onlines']:
            online['DataFrame'] = to_DataFrame(online['variables'], online['values'], args)
            # here we deal with a bug that is in MQXF furnace CSV format:
            online['DataFrame']['Time'] = online['DataFrame']['Offset zone B8'] 
       
	cpickle_dump(RHTdata, pickle_path)
        return RHTdata

def target_ranges_str(args):
    ss = [str(s[0])+'-'+str(s[1]) for s in args.dwell_target_ranges]
    return "_".join(ss)

def parameters_str(args):
#            print "dtdev = dwell target deviation"
#            print "dthom = dwell target homogeneity"
#            print "dthomhalf = dwell target homogeneity half band"
#            print "dhtol = dwell heat_rate tolerance"
#            print "dtdev\tdthom\tdthomhalf\tdhtol"
#            print 
    return ""
    if args.no_target_ranges:
        out = "dtdev{}-dthomhalf{}-dhtol{}".format(args.dwell_target_deviation, args.dwell_target_homogeneity_half_band, args.dwell_heat_rate_tolerance)
    else:
        out = "dthomhalf{}".format(args.dwell_target_deviation) + "_dtr" + target_ranges_str(args)
    return out.replace('.','_')


def parameters_dict(args):
    params = {'dtdev':args.dwell_target_deviation,
              'dthomhalf':args.dwell_target_homogeneity_half_band, 
              'dhtol':args.dwell_heat_rate_tolerance}
    return params

def to_DataFrame(variables, values, args):

    if len(values) > 0:
        #variables = RHTdata['data_logging']['variables']
        #values = np.array(RHTdata['data_logging']['values'])
        #RHTdata['data_logging']['DataFrame'] = pd.DataFrame({variable:values[:,i] for i,variable in enumerate(variables)})
        values = np.array(values)
        #print variables, values
        DataFrame = pd.DataFrame({variable:values[:,i] for i,variable in enumerate(variables)})
        for i, col in enumerate(DataFrame.keys()):
            try:
                DataFrame[col] = pd.to_numeric(DataFrame[col])
            except:
                pass
        if 'date' in DataFrame.keys() and 'time' in DataFrame.keys():
            DataFrame['datetime'] = to_datetime(DataFrame['date'], DataFrame['time'], args)
            DataFrame['seconds'] = (DataFrame['datetime'] - DataFrame['datetime'][0]).dt.total_seconds()
            DataFrame['hours'] = DataFrame['seconds']/3600
    else:
        print "to_DataFrame: no values to be converted! returning 'None'"
        DataFrame = None

    return DataFrame

@timeit
def cpickle_dump(data, pickle_path):
	with open(pickle_path, 'wb') as handle:
		pickle.dump(data, handle, protocol=pickle.HIGHEST_PROTOCOL)

@timeit
def cpickle_load(pickle_path):
	with open(pickle_path, 'rb') as handle:
		mtbop_data = pickle.load(handle)
	return mtbop_data

def to_datetime(dates, times, args):
    datetimes = []
    clock_change = 0
    for i, date in enumerate(dates):
        dateparts = date.split('.')[::-1]
        datetimes.append(datetime.datetime.strptime('-'.join(dateparts) + 'T' + times[i], '%Y-%m-%dT%H:%M:%S'))
        if not args.no_clock_change_detection:
            if i>=1:
                dt = (datetimes[i]-datetimes[i-1]).total_seconds() 
                if clock_change != 1 and dt < -3500:
                    print "to_datetime: clock change to winter time detected (i=",str(i),"datetime=",datetimes[i],"dt =", str(dt) + "). All the following times are changed back to summer time." 
                    clock_change = 1
                elif clock_change !=2 and dt > 3500:
                    print "to_datetime: clock change to summer time detected (i=",str(i),"datetime=",datetimes[i],"dt =", str(dt) + "). All the following times are changed back to winter time." 
                    clock_change = 2
            if clock_change == 1:
                datetimes[i] += datetime.timedelta(hours=1)
            elif clock_change == 2:
                datetimes[i] -= datetime.timedelta(hours=1)

#datetimeObj = datetime.strptime('2018-09-11T15::11::45.456777', '%Y-%m-%dT%H::%M::%S.%f')
    return datetimes

def abs_diff_filter(logging_df, TC_all_df, diff_max=500., only_ramp_ups=True):
    TC_mean = TC_all_df.mean(axis=1)
    TC_mean_rate = np.gradient(TC_mean, logging_df['seconds'])
    accepted_TC_keys = []
    for key in TC_all_df.keys():
        if only_ramp_ups:
            TC_Ramp_ups = TC_all_df[TC_mean_rate>0]
            diff = TC_Ramp_ups[key]-TC_mean
        else:
            diff = TC_all_df[key]-TC_mean
            
        if not (diff.abs() > diff_max).any():
            accepted_TC_keys.append(key)

    return accepted_TC_keys

def abs_diff_filters(logging_df, TC_all_df, tdf_list = [500., 30.], only_ramp_ups=True):
    print "tdf_list", tdf_list
    accepted_TC_df_list = TC_all_df
    accepted_keys_rounds = []
    for tdf in tdf_list:
        accepted_keys = abs_diff_filter(logging_df, accepted_TC_df_list, tdf, only_ramp_ups)
        accepted_TC_df_list = TC_all_df[accepted_keys]
        accepted_keys_rounds.append(accepted_keys)

    if len(accepted_keys) == 0:
        print "abs_diff_filters: None of the y-axis variables were accepted! Exiting..."
        exit()

    rejected_keys = list(set(TC_all_df).difference(set(accepted_keys)))
    print "Rejected keys:", rejected_keys

    return accepted_keys, rejected_keys, accepted_keys_rounds

@timeit
def find_dwells(logging, args):
    logging_df = logging['DataFrame']
    accepted_TC_keys = logging['accepted_TC_keys']
    dwells = []
    for i, target in enumerate(args.dwell_target_temperatures):
        dwells.append({})
        dwell = dwells[-1]
        dwell['n'] = i + 1
        dwell['Ttarget'] = target
        dwell['target_ranges'] = args.dwell_target_ranges
        dwell['DataFrame'] = logging_df.copy(deep=True)
        dwell_df = dwell['DataFrame']
        dwell['TC durations'] = {}
        dwell['TC durations']['TC'] = []
        dwell['TC durations']['durations'] = []
        dwell['TC durations']['start'] = []
        dwell['TC durations']['end'] = []
        if args.no_target_ranges:
            for key in accepted_TC_keys: 
                diff = dwell_df[key]-target
                dwell_df = dwell_df[diff.abs()<args.dwell_target_deviation]
                dwell['TC durations']['TC'].append(key)
                dwell['TC durations']['start'].append(dwell_df['hours'].values[0])
                dwell['TC durations']['end'].append(dwell_df['hours'].values[-1])
                dwell['TC durations']['durations'].append(dwell_df['hours'].values[-1] - dwell_df['hours'].values[0])
            dwell_df = dwell_df[dwell_df['dmeanTdt'].abs()<args.dwell_heat_rate_tolerance]
            dwell_df = dwell_df[dwell_df['dmeanTdt']>-0.0001]
            if args.dwell_mid_deviation != None:
                dwell_df = dwell_df[(dwell_df['Tmid']-target).abs()<args.dwell_mid_deviation]
        else:
            #mid_target = (args.dwell_target_ranges[i][0] + args.dwell_target_ranges[i][1])/2
            #dwell_df = dwell_df[(dwell_df['Tmid']-mid_target).abs()<mid_target/20.]
            #dwell_df = dwell_df[dwell_df['dmeanTdt'].abs()<0.01]
            #dwell_df = dwell_df[(dwell_df['dmeanTdt'])>-0.06]
            for key in accepted_TC_keys: 
                dwell_df = dwell_df[dwell_df[key] >= args.dwell_target_ranges[i][0]]
                dwell_df_key = dwell['DataFrame'][dwell['DataFrame'][key] >= args.dwell_target_ranges[i][0]]
                try:
                    dwell['TC durations']['TC'].append(key)
                    dwell['TC durations']['start'].append(dwell_df_key['hours'].values[0])
                except:
                    print "The start of dwell", str(dwell['n']), "for key", key, "was not found."
                    pass
            try:
                hours_start = dwell_df['hours'].values[0]
            except:
                print "Dwell", str(dwell['n']), "start not found."
                pass

            for k, key in enumerate(accepted_TC_keys): 
                dwell_df = dwell_df[dwell_df[key] <= args.dwell_target_ranges[i][1]]
                dwell_df_key = dwell['DataFrame'][dwell['DataFrame'][key] >= args.dwell_target_ranges[i][0]]
                dwell_df_key = dwell_df_key[dwell_df_key[key] <= args.dwell_target_ranges[i][1]]
                try:
                    dwell['TC durations']['end'].append(dwell_df_key['hours'].values[-1])
                    dwell['TC durations']['durations'].append(dwell['TC durations']['end'][k] - dwell['TC durations']['start'][k])
                except:
                    print "The end of dwell", str(dwell['n']), "for key", key, "was not found."
                    pass
            try:
                hours_end = dwell_df['hours'].values[-1]
                dwell_df = logging_df.copy(deep=True)
                dwell_df = dwell_df[dwell_df['hours'] >= hours_start]
                dwell_df = dwell_df[dwell_df['hours'] <= hours_end]
                dwell['hours_start'] = hours_start
                dwell['hours_end'] = hours_end
                dwell['duration'] = hours_end-hours_start
                print "Dwell", str(dwell['n']), "duration", str(dwell['duration'])
            except: 
                print "Dwell", str(dwell['n']), "end not found."
                pass

        dwell['DataFrame'] = dwell_df

    if args.dwell_target_homogeneity_half_band != None:
        args.dwell_target_homogeneity = 2.* args.dwell_target_homogeneity_half_band

    if args.dwell_target_homogeneity != None:
        args.dwell_target_homogeneity_half_band = args.dwell_target_homogeneity/2.
        dwells_tmp = []
        for i, dwell in enumerate(dwells):
            dwell_df = dwell['DataFrame']
            #print i, dwell_df[accepted_TC_keys].min, dwell_df[accepted_TC_keys].max
            accepted_values = dwell_df[accepted_TC_keys]
            diff = accepted_values.min(1)-accepted_values.max(1)
            dwell_df = dwell_df[diff.abs()<args.dwell_target_homogeneity]
            dwell['DataFrame'] = dwell_df 
            dwells_tmp.append(dwell)
    else:
        dwells_tmp = dwells

    dwells = []
    for i, dwell in enumerate(dwells_tmp):
        dwell_df = dwell['DataFrame']
        if dwell_df['hours'].size > 0:
            dwell['duration'] = dwell_df['hours'].iloc[-1] - dwell_df['hours'].iloc[0]
            dwell['Tmeanmean'] = dwell_df[accepted_TC_keys].mean().mean()
            dwell['Tminmin'] = dwell_df[accepted_TC_keys].min().min()
            dwell['Tmaxmax'] = dwell_df[accepted_TC_keys].max().max()
            if 'hours_end' in dwell:
                dwell['Tmaxmax_prec'] = logging_df[logging_df['hours']<= dwell['hours_start']][accepted_TC_keys].max().max()
            else:
                dwell['Tmaxmax_prec'] = None
            dwell['Tmid'] = (dwell['Tmaxmax']+dwell['Tminmin'])/2.
            dwell['Tmid dev'] = dwell['Tmid']-dwell['Ttarget']
            dwell['Tmidmean'] = (dwell_df[accepted_TC_keys].max(axis=1) + dwell_df[accepted_TC_keys].min(axis=1)).mean()/2.
            dwell['Tmidmean dev'] = dwell['Tmidmean']-dwell['Ttarget']

            dwell['Tminmean'] = dwell_df[accepted_TC_keys].min().mean()
            dwell['Tmaxmean'] = dwell_df[accepted_TC_keys].max().mean()

            dwell['Tmeanmid'] = (dwell['Tmaxmean'] + dwell['Tminmean'])/2.
            dwell['Tmeanmid dev'] = dwell['Tmeanmid']-dwell['Ttarget']

            dwell['Hmean'] = (dwell_df[accepted_TC_keys].max(axis=1) - dwell_df[accepted_TC_keys].min(axis=1)).mean()
            dwell['dwell_asymptot'] = dwell_df[dwell_df['hours'] >= dwell_df['hours'].max()-2]
            dwell['dwell_asymptot'] = dwell['dwell_asymptot'][dwell['dwell_asymptot']['hours'] <= dwell['dwell_asymptot']['hours'].max()-1]
            dwell_asymptot = dwell['dwell_asymptot'] 
            dwell['Hasmax'] = (dwell_asymptot[accepted_TC_keys].max().max() - dwell_asymptot[accepted_TC_keys].min().min())
            dwell['Hasmin'] = (dwell_asymptot[accepted_TC_keys].max(axis=1) - dwell_asymptot[accepted_TC_keys].min(axis=1)).min()
            dwell['Hasmean'] = (dwell_asymptot[accepted_TC_keys].max(axis=1) - dwell_asymptot[accepted_TC_keys].min(axis=1)).mean()
            dwell['Hmax'] = (dwell_df[accepted_TC_keys].max(axis=1) - dwell_df[accepted_TC_keys].min(axis=1)).max()
            dwell['Hmax/2'] = dwell['Hmax']/2.
            dwell['Hmean/2'] = dwell['Hmean']/2.
            dwell['Hasmax/2'] = dwell['Hasmax']/2. 
            dwell['Hasmin/2'] = dwell['Hasmin']/2. 
            dwell['Hasmean/2'] = dwell['Hasmean']/2. 

            if dwell['duration'] > args.minimum_dwell_duration:
                dwells.append(dwell)

    return dwells

def find_TC_durations(RHTdata, args):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    accepted_TC_keys = logging['accepted_TC_keys']
    dwells = RHTdata['dwells']
    for dwell in dwells:
        dwell['TC durations2'] = {}
        dwell['TC durations2']['TC'] = []
        dwell['TC durations2']['durations'] = []
        dwell['TC durations2']['start'] = []
        dwell['TC durations2']['end'] = []
        dwell['TC durations3'] = {}
        dwell['TC durations3']['TC'] = []
        dwell['TC durations3']['durations'] = []
        dwell['TC durations3']['start'] = []
        dwell['TC durations3']['end'] = []
        dwell_df = dwell['DataFrame']
        T0 = args.T0
        for key in accepted_TC_keys:
            test_df = logging_df.copy(deep=True)
            TC_mean = dwell_df[key].mean()
            diff = test_df[key] - TC_mean 
            test_df = test_df[diff.abs()<665.-T0]
            dwell['TC durations2']['TC'].append(key)
            dwell['TC durations2']['start'].append(test_df['hours'].values[0])
            dwell['TC durations2']['end'].append(test_df['hours'].values[-1])
            dwell['TC durations2']['durations'].append(test_df['hours'].values[-1] - test_df['hours'].values[0])
        for key in accepted_TC_keys:
            test_df = logging_df.copy(deep=True)
            diff = test_df[key] - 665.
            test_df = test_df[diff.abs()<665-T0]
            dwell['TC durations3']['TC'].append(key)
            dwell['TC durations3']['start'].append(test_df['hours'].values[0])
            dwell['TC durations3']['end'].append(test_df['hours'].values[-1])
            dwell['TC durations3']['durations'].append(test_df['hours'].values[-1] - test_df['hours'].values[0])



def IT_weights(T, T0=600., T1=650., w0=0., w1=1.):
    weights = (w1-w0)/(T1-T0) * (T-T0)
    weights[weights < w0] = w0
    weights[weights > w1] = w1
    return weights

def compute_TC_ITs(RHTdata, args):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    accepted_TC_keys = logging['accepted_TC_keys']
    RHTdata['Integrated Temperatures'] = []
    RHTdata['Integrated Durations'] = []
    RHTdata['Sharp Durations'] = []
    Treact = args.dwell_target_temperatures[2]
    for key in accepted_TC_keys:
        TC_values = logging_df[key].values
        nan_index=np.argwhere(np.isnan(TC_values)).T[0]
        while np.size(nan_index) > 0:
            TC_values[nan_index] = TC_values[nan_index-1]
            nan_index=np.argwhere(np.isnan(TC_values)).T[0]
        T1 = args.T1
        T0 = args.T0
        Tref = T0
        dt1 = 50. * 3600.
        w_values = IT_weights(TC_values, T0=T0, T1=T1, w0=0., w1=1.)
        t_r = np.trapz(np.heaviside(TC_values-Tref,1),logging_df['seconds'])/3600.
        RHTdata['Sharp Durations'].append(t_r)
        RHTdata['Integrated Durations'].append(np.trapz(w_values,logging_df['seconds'])/3600.)
        RHTdata['Integrated Temperatures'].append((T1-T0)*np.divide(np.trapz(w_values,logging_df['seconds'])/3600.,t_r)+T0)
    RHTdata['Sharp Durations'] = np.array(RHTdata['Sharp Durations'])
    RHTdata['Integrated Durations'] = np.array(RHTdata['Integrated Durations'])
    RHTdata['Integrated Temperatures'] = np.array(RHTdata['Integrated Temperatures'])


def print_dwells(dwells, args):
    print "Dwell\tduration(h)\tmax(T)\tmean(T)\tmin(T)\t Max Homogeneity half band"
    for i, dwell in enumerate(dwells):
        dwell_df = dwell['DataFrame']
        print "{:d}\t{:3.1f}\t{:3.0f}\t{:3.0f}\t{:3.0f}\t{:3.1f}".format(dwell['n'], dwell['duration'], dwell['Tmaxmax'], dwell['Tmeanmean'], dwell['Tminmin'], dwell['Hmax/2'])

def fetch_dwell_by_number(dwells, n):
    #print [dwell['n'] for dwell in dwells]
    for dwell in dwells:
        if n == dwell['n']:
            return dwell
    return None

def add_col_to_print_dict(print_dict, col):
    print_dict[col] = []
    if 'header cols' not in print_dict:
        print_dict['header cols'] = []
    print_dict['header cols'].append(col)

def collect_summary_df(dwells, args, RHTdata):
    print_params = {}
    add_col_to_print_dict(print_params, 'Dwell')
    add_col_to_print_dict(print_params, 'File')
    add_col_to_print_dict(print_params, 'Coil ID')
    #add_col_to_print_dict(print_params, 'Target_H/2')
    #add_col_to_print_dict(print_params, 'Target_dev')
    #add_col_to_print_dict(print_params, 'Target_HR')

    add_col_to_print_dict(print_params, 'duration')
    add_col_to_print_dict(print_params, 'Target_T')
    add_col_to_print_dict(print_params, 'Allowed_Band')
    add_col_to_print_dict(print_params, 'Tmaxmax')
    add_col_to_print_dict(print_params, 'Tmaxmax_prec')
    add_col_to_print_dict(print_params, 'Tmaxmean')
    add_col_to_print_dict(print_params, 'Tmeanmean')
    add_col_to_print_dict(print_params, 'Tminmean')
    add_col_to_print_dict(print_params, 'Tminmin')
    add_col_to_print_dict(print_params, 'Tmid')
    add_col_to_print_dict(print_params, 'Tmid_dev')
    add_col_to_print_dict(print_params, 'Tmidmean')
    add_col_to_print_dict(print_params, 'Tmidmean_dev')
    add_col_to_print_dict(print_params, 'Tmeanmid')
    add_col_to_print_dict(print_params, 'Tmeanmid_dev')
    add_col_to_print_dict(print_params, 'Hmax/2')
    add_col_to_print_dict(print_params, 'Hmean/2')
    add_col_to_print_dict(print_params, 'Hasmax/2')
    add_col_to_print_dict(print_params, 'Hasmin/2')
    add_col_to_print_dict(print_params, 'Hasmean/2')
    print_cols = print_params.pop('header cols', None)

    p = parameters_dict(args)

    for i, target in enumerate(args.dwell_target_temperatures):
        dtr = args.dwell_target_ranges[i]
        n=i+1
        print_params['Dwell'].append(n)
        print_params['File'].append(args.path)
        print_params['Coil ID'].append(RHTdata['Coil ID'])
        #print_params['Target_H/2'].append(p['dthomhalf'])
        #print_params['Target_dev'].append(p['dtdev'])
        #print_params['Target_HR'].append(p['dhtol'])
        dwell = fetch_dwell_by_number(dwells, n)
        if dwell != None:
            print_params['duration'].append(dwell['duration'])
            print_params['Target_T'].append(float(target))
            print_params['Allowed_Band'].append(dtr)
            print_params['Tmaxmax'].append(dwell['Tmaxmax'])
            print_params['Tmaxmax_prec'].append(dwell['Tmaxmax_prec'])
            print_params['Tmaxmean'].append(dwell['Tmaxmean'])
            print_params['Tmeanmean'].append(dwell['Tmeanmean'])
            print_params['Tminmean'].append(dwell['Tminmean'])
            print_params['Tminmin'].append(dwell['Tminmin'])
            print_params['Tmid'].append(dwell['Tmid'])
            print_params['Tmid_dev'].append(dwell['Tmid dev'])
            print_params['Tmidmean'].append(dwell['Tmidmean'])
            print_params['Tmidmean_dev'].append(dwell['Tmidmean dev'])
            print_params['Tmeanmid'].append(dwell['Tmeanmid'])
            print_params['Tmeanmid_dev'].append(dwell['Tmeanmid dev'])
            print_params['Hmax/2'].append(dwell['Hmax/2'])
            print_params['Hmean/2'].append(dwell['Hmean/2'])
            print_params['Hasmax/2'].append(dwell['Hasmax/2'])
            print_params['Hasmin/2'].append(dwell['Hasmin/2'])
            print_params['Hasmean/2'].append(dwell['Hasmean/2'])
        else:
            print_params['duration'].append(None)
            print_params['Target_T'].append(None)
            print_params['Allowed_Band'].append(None)
            print_params['Tmaxmax'].append(None)
            print_params['Tmaxmax_prec'].append(None)
            print_params['Tmaxmean'].append(None)
            print_params['Tmeanmean'].append(None)
            print_params['Tminmean'].append(None)
            print_params['Tminmin'].append(None)
            print_params['Tmid'].append(None)
            print_params['Tmid_dev'].append(None)
            print_params['Tmidmean'].append(None)
            print_params['Tmidmean_dev'].append(None)
            print_params['Tmeanmid'].append(None)
            print_params['Tmeanmid_dev'].append(None)
            print_params['Hmax/2'].append(None)
            print_params['Hmean/2'].append(None)
            print_params['Hasmax/2'].append(None)
            print_params['Hasmin/2'].append(None)
            print_params['Hasmean/2'].append(None)
    summary_df = pd.DataFrame(print_params)
    return summary_df, print_cols

def print_parameters_and_dwells(dwells, args):
    global print_parameters_and_dwells_calls
    print_parameters_and_dwells_calls += 1
    dwell_line = "File\tTarget H/2\tTarget dev\tTarget HR\t"
    for i, target in enumerate(args.dwell_target_temperatures):
        n = i+1
        dwell = fetch_dwell_by_number(dwells, n)
        if dwell != None:
            dwell_line += str(n) + ". Tmeanmean (C)\t" + str(n) + ". duration"  + "(h)\t" + str(n) + ". Max H/2 (h)\t"
        else:
            dwell_line += str(n) + ". Tmeanmean (C)\t" + str(n) + ". duration"  + "(h)\t" + str(n) + ". Max H/2 (h)\t"
#         print "dtdev = dwell target deviation"
#            print "dthom = dwell target homogeneity"
#            print "dthomhalf = dwell target homogeneity half band"
#            print "dhtol = dwell heat_rate tolerance"
#            print "dtdev\tdthom\tdthomhalf\tdhtol"
    if print_parameters_and_dwells_calls == 1:
        file_logger.write(dwell_line)

    p = parameters_dict(args)
    dwell_line = args.path+"\t{:3.1f}\t{:3.1f}\t{:3.4f}\t".format(p['dthomhalf'], p['dtdev'], p['dhtol'])
    for i, target in enumerate(args.dwell_target_temperatures):
        n=i+1
        dwell = fetch_dwell_by_number(dwells, n)
        if dwell != None:
            dwell_line += "{:3.1f}\t{:3.1f}\t{:3.1f}\t".format(dwell['Tmeanmean'], dwell['duration'], dwell['Hmax/2'])
        else:
            dwell_line += "{:3.1f}\t{:3.1f}\t{:3.1f}\t".format(-1., -1., -1.)
    file_logger.write(dwell_line)


def find_dwells_target_temperatures(program_df, args):
    program_df[program_df['Time hours'].le(args.dwell_duration_min)]

def regenerate_program_data(program_df):
    program_df['Time hours'] = program_df['Time']/60.
    program_df['hours from'] = program_df['Time hours'].cumsum()-program_df['Time hours']
    program_df['hours to'] = program_df['Time hours'].cumsum()

def find_program_step_using_datetime(logging_df, dt):
    ind = pd.Index(logging_df['datetime']).get_loc(dt, method='nearest')
    return logging_df['Step'][ind]
 
def regenerate_online_data(RHTdata):
    program = RHTdata['program']
    program_df = RHTdata['program']['DataFrame']
    regenerate_program_data(program_df)

    #plotter.plot_ax(program_df['hours from'],program_df['From Tp zone B3'], label='Program')

    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']

    latest_program = program
    program['activation datetime'] = RHTdata['data_loggings'][0]['DataFrame']['datetime'][0]
    program['activation seconds'] = (program['activation datetime'] - logging_df['datetime'][0]).total_seconds()
    program['activation hours'] = program['activation seconds']/3600.
    #program['activation_step'] = find_program_step_using_datetime(logging_df, program['activation datetime'])
    for i, online in enumerate(RHTdata['onlines']):
        latest_program_df = latest_program['DataFrame']
        online_df = online['DataFrame']
        online['activation datetime'] = RHTdata['data_loggings'][i+1]['DataFrame']['datetime'][0]
        online['activation seconds'] = (online['activation datetime'] - RHTdata['data_loggings'][0]['DataFrame']['datetime'][0]).total_seconds()
        online['activation hours'] = online['activation seconds']/3600.
        #online['activation_step'] = find_program_step_using_datetime(logging_df, online['activation datetime'])
        latest_program['deactivation datetime'] = online['activation datetime'] 
        latest_program['deactivation seconds'] = online['activation seconds'] 
        latest_program['deactivation hours'] = online['activation hours'] 
        for key in latest_program_df.keys():
            if key not in online_df.keys():
                online_df[key]=latest_program_df[key]
        
        online['change'] = latest_program_df.ne(online_df)
        regenerate_program_data(online_df)
        latest_program = online

def thermocouple_interp_mapping(filepath):
    ct = pd.read_table(filepath)
    interp_mapping = {}
    print "Generating linear interpolator for thermo-couples"
    for Id in list(set(ct['Id'])):
        try:
            print "Thermo-couple id", Id
            x_vec = pd.to_numeric(ct.loc[ct['Id']==Id]['Tmeas'])
            y_vec = pd.to_numeric(ct.loc[ct['Id']==Id]['Tdev'])
            #print "Tmeas:", x_vec.values
            #print "Tdev:", y_vec.values
            interp_mapping[Id] = scipy.interpolate.InterpolatedUnivariateSpline(x_vec, y_vec,k=1)
            #print "interp", str(200), interp(200)
            #print "interp", str(400), interp(400)
            #print "interp", str(660), interp(660)
        except:
            pass
    return interp_mapping

def get_TCid(key):
    #example PV +MT3.0 TC-N-4.0
    if 'TC-N-' in key:
        try:
            return key.split('TC-N-')[1].split('.')[0]
        except:
            pass
    else:
        try:
            return key.split(':')[0].split(' ')[1]
        except:
            pass
    return None

def sort_list_by_block_number(accepted_TC_keys):
    l = [(int(key.split(':')[1].split()[1]), key) for key in accepted_TC_keys]
    keys_out = [key[1] for key in sorted(l, key=lambda x: x[0])]
    return keys_out

@timeit
def analyze(RHTdata, args):
    RHTdata['dwell_target_ranges'] = args.dwell_target_ranges
    RHTdata['Coil ID'] = RHTdata['path'].replace('.csv','').split('_')[0]
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']

    if args.list_variables:
        print "Variable list:"
        print "--------------"
        for key in logging_df.keys():
            print key  

    x = logging_df['hours']

    if not args.thermo_couple_calibration == None:
        RHTdata['TC_interp_mapping'] = thermocouple_interp_mapping(args.thermo_couple_calibration)
        ip_map = RHTdata['TC_interp_mapping'] 
        for key in logging_df:
            TCid = get_TCid(key)
            if TCid != None and TCid in ip_map:
                logging_df[key] += ip_map[TCid](logging_df[key])
            else:
                print "Calibration not found for:", key

    if not args.y_axis == None:
        TC_all_df = logging_df[args.y_axis]
    else:
        if 'TC_mapping' not in RHTdata:
            print "analyze(): note, I didn't find a thermo-couple mapping!"
            TC_all_df = logging_df[[y for y in logging_df.keys() if ('MT' in y and 'PV' in y and 'TC' in y)]]
        else:
            print "Thermo-couple mapping found!"
            TC_all_df = logging_df[[y for y in logging_df.keys() if 'block' in y.lower() and 'air support' not in y.lower()]]

    RHTdata['TC_all_df'] = TC_all_df
    logging['accepted_TC_keys'], logging['rejected_TC_keys'], logging['accepted_keys_rounds'] = abs_diff_filters(logging_df, TC_all_df, args.temperature_deviation_filters)
    logging['accepted_TC_keys'] = sort_list_by_block_number(logging['accepted_TC_keys'])
     
    accepted_TC_df_list = logging_df[logging['accepted_TC_keys']]

    logging_df['Tmean'] = accepted_TC_df_list.mean(axis=1)
    logging_df['Tmin'] = accepted_TC_df_list.min(axis=1)
    logging_df['Tmax'] = accepted_TC_df_list.max(axis=1)
    logging_df['H'] = logging_df['Tmax'] - logging_df['Tmin'] 
    logging_df['Tmid'] = (logging_df['Tmax'] + logging_df['Tmin'])/2.
    logging_df['dmeanTdt'] = np.gradient(logging_df['Tmean'], logging_df['seconds'])

    #dwell_target_temperatures = find_dwells_target_temperatures(program_df, args)

    RHTdata['duration_based_target_temperatures'] = False
    if not args.dwell_duration_minimum == None:
        RHTdata['duration_based_target_temperatures'] = True
        args.dwell_target_temperatures = sorted(list(set(program_df[program_df['Time hours'].ge(args.dwell_duration_minimum)]['From Tp zone B3'])))
    dwells = find_dwells(logging, args)
    print_dwells(dwells, args)
    summary_df, print_cols = collect_summary_df(dwells, args, RHTdata)
    RHTdata['summary_df'] = summary_df
    param = summary_df[print_cols]
    file_logger.write(param.to_string())
    #tex_cols = ['Coil ID', 'duration', 'Target_T', 'Allowed_Band', 'Tmaxmax_prec', 'Tmaxmax', 'Tmid', 'Tminmin', 'Hmax/2', 'Tmaxmean','Tmidmean', 'Tminmean', 'Hmean/2', 'Hasmax/2','Hasmean/2']
    tex_cols = ['Coil ID', 'duration', 'Target_T', 'Allowed_Band', 'Tmaxmax_prec', 'Tmaxmax', 'Tminmin', 'Hmax/2', 'Hasmax/2', 'Tmaxmean', 'Tmidmean', 'Tminmean', 'Hmean/2','Hasmean/2']
    file_logger.write_table(param[tex_cols].transpose().to_latex(index=False, float_format="{:0.1f}".format))
    report.store_table(to_math(param[tex_cols].transpose().to_latex(header=False, float_format="{:0.1f}".format)), 'table:summary', caption='Dwell summary')
    #print_parameters_and_dwells(dwells, args)
    RHTdata['dwells'] = dwells
    RHTdata['start date'] = logging_df['datetime'].iloc[0].strftime('%Y-%m-%d')
    RHTdata['end date'] = logging_df['datetime'].iloc[-1].strftime('%Y-%m-%d')
    find_TC_durations(RHTdata, args)
    compute_TC_ITs(RHTdata, args)

def plot_all_TC(RHTdata, args):
    plotter.set_lim_args(args)
    xargs_old = plotter.ax.get_xlim()
    args.xlim = (0, 300)
    plotter.set_lim_args(args)
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    TC_all_df = RHTdata['TC_all_df'] 

    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Temperature ($\degree$C)')
    for key in TC_all_df.keys():
        plotter.plot_ax(logging_df['hours'], TC_all_df[key], label=key)

    plotter.legend(loc='upper center', bbox_to_anchor=(0.5,-.1), fancybox=True, shadow=True, ncol=8)

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:all_TC', '_all_TC_' + parameters_str(args) + '.png', args=args, caption='The temperature reading of every thermo-couple as a function of hours from the beginning of the reaction cycle.')
    args.xlim = xargs_old 

def plot_accepted_TC(RHTdata, args):
    plotter.set_lim_args(args)
    xargs_old = plotter.ax.get_xlim()
    args.xlim = (0,300)
    plotter.set_lim_args(args)
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    #plotter.plot_ax(program_df['hours from'],program_df['From Tp zone B3'], label='Program')
    plotter.plot_dwells(dwells)

    for i, keys in enumerate(logging['accepted_keys_rounds']):
        plotter.set_lim_args(args)
        plotter.set_xlabel('Time (h)')
        plotter.set_ylabel('Temperature ($\degree$C)')
        plotter.plot_ax(logging_df['hours'], logging_df[keys].mean(axis=1), label='mean(T)', linewidth=linewidth)
        for key in keys:
            plotter.plot_ax(logging_df['hours'], logging_df[key], label=key)

        plotter.legend(loc='upper center', bbox_to_anchor=(0.5,-.1), fancybox=True, shadow=True, ncol=8)

        if args.show_plot:
            plotter.show(args)
        else:
            fig_filename = args.path.replace('.csv','') 
            plotter.savefig(fig_filename, 'fig:accepted_TC', '_accepted_TC_round_' + parameters_str(args) + '_' + str(i) + '.png', args=args, caption='The temperature reading of the accepted thermo-couple as a function of hours from the beginning of the reaction cycle.')
    args.xlim = xargs_old 

def plot_Ar(RHTdata, args):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Flow (l/h)')
    plotter.plot_ax(logging_df['hours'],logging_df['PV +GP1.0 MFC-1.0 Ar retort'], label='Ar retort')
    plotter.plot_ax(logging_df['hours'],logging_df['PV +GP1.0 MFC-1.1 Ar tooling'], label='Ar tooling')

    plotter.set_ax2()
    plotter.set_ylabel2('Temperature ($\degree$C)')
    plotter.plot_ax2(logging_df['hours'],logging_df['Tmean'], label='mean(T)')
    plotter.set_lim_args(args)

    plotter.plot_dwells(dwells)
    plotter.plot_onlines(RHTdata, plot_curves=False)
    plotter.write_dwell_notes(args)
    plotter.write_tc_notes(RHTdata, rejected=True)

    plotter.legend(loc='best')

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:Ar', '_Ar_' + parameters_str(args) + '.png', args=args, caption='Argon flow inside the retort and the tooling as a function of time.')

def plot_heating_rate(RHTdata, args):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Heating Rate ($\degree$C/h)')
    plotter.plot_ax(logging_df['hours'],logging_df['dmeanTdt']*3600., label='d(mean(T))/dt')
    plotter.set_ax2()
    plotter.set_ylabel2('Temperature ($\degree$C)')
    plotter.plot_ax2(logging_df['hours'],logging_df['Tmean'], label='mean(T)')
    plotter.set_lim_args(args)

    plotter.plot_dwells(dwells, vertical_position=0.7)
    plotter.plot_onlines(RHTdata, plot_curves=False)
    plotter.write_dwell_notes(args)
    plotter.write_tc_notes(RHTdata, rejected=True)

    plotter.legend(loc='best')

    #plotter.ax.set_xlim((0.,dwells[-1]['hours'].max()+120.))

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:heating_rate', '_heating_rate_' + parameters_str(args) + '.png', args=args, caption = 'Heating rate as a function of time.')

def plot_homogeneity(RHTdata, args):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Homogeneity ($\degree$C)')
    plotter.plot_ax(logging_df['hours'],logging_df['H']/2., label='H/2')
    plotter.set_ax2()
    plotter.set_ylabel2('Flow (l/h)')
    #plotter.plot_ax2(logging_df['hours'],logging_df['PV +GP1.0 MFC-1.0 Ar retort'], label='Ar retort')
    plotter.plot_ax2(logging_df['hours'],logging_df['PV +GP1.0 MFC-1.1 Ar tooling'], label='Ar tooling')
    #plotter.plot_ax(logging_df['hours'],logging_df['Tmean'])
    plotter.set_lim_args(args)
    plotter.set_ylim((0,10))

    plotter.plot_dwells(dwells, vertical_position=0.4)
    plotter.plot_onlines(RHTdata, plot_curves=False)
    plotter.write_dwell_notes(args)
    plotter.write_tc_notes(RHTdata, rejected=True)

    plotter.legend(loc='best')

    #plotter.ax.set_xlim((0.,dwells[-1]['hours'].max()+120.))

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:homogeneity', '_homogeneity_' + parameters_str(args) + '.png', args=args, caption='Homogeneity of the fixture according to the accepted thermo-couples.')

def plot_TC_dwell_durations(RHTdata, args, dwell_nr=2, f_of_position=False):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwell = RHTdata['dwells'][dwell_nr]
    accepted_TC_keys = RHTdata['data_logging']['accepted_TC_keys']

    fig_filename = args.path.replace('.csv','') 
    #try:
    T0T1text = '$T_0$ = {:0.0f} $^\circ C$'.format(args.T0)
    T0T1text += '\n$T_1$ = {:0.0f} $^\circ C$'.format(args.T1)
    if f_of_position:
        plotter.clear((16,10))
        T0T1text = '$T_0$ = {:0.0f} $^\circ C$'.format(args.T0)
        plotter.add_text_to_legend(T0T1text)
        plotter.set_xlabel('Longitudinal position(m)')
        plotter.set_ylabel('Dwell duration')
        xdata = [block_to_position(float(key.split(':')[1].split('block ')[1])) for key in accepted_TC_keys]
        marker = plotter.get_marker()
        color = plotter.get_color()
        plotter.plot_ax(xdata, dwell['TC durations3']['durations'], label='absolute criterion', color=color, marker=marker)
        marker = plotter.get_marker()
        color = plotter.get_color()
        plotter.plot_ax(xdata, dwell['TC durations2']['durations'], label='relative criterion', color=color, marker=marker)

        if 'CR114' in fig_filename:
            plotter.set_ax2()
            RRR = np.array([306,289,286,266,242,260,247,243,247,236])
            RRRdeg = (354.-RRR)/354. * 100.
            ind = np.array(range(len(RRR)))+1
            blocks = np.array([3,7,13,23,33,43,53,63,73,78])
            pos = block_to_position(blocks)
            marker = plotter.get_marker()
            color = plotter.get_color()
            plotter.plot_ax2(pos, RRRdeg, label="RRR deg.", marker=marker, color=color)
            plotter.set_ylabel2('RRR degradation (%)')

        fig_filename += "fofpos"
    else:
        plotter.set_xlabel('TC')
        plotter.set_ylabel('Dwell ' + str(dwell_nr+1) + ' duration (h)')
        xdata = range(len(dwell['TC durations']['TC']))

        marker = plotter.get_marker()
        color = plotter.get_color()
        plotter.plot_ax(xdata, dwell['TC durations3']['durations'], label='absolute criterion', color=color, marker=marker)
        #plotter.plot_ax(xdata, dwell['TC durations']['durations'], label='absolute criterion', color=color, marker=marker)
        marker = plotter.get_marker()
        color = plotter.get_color()
        plotter.plot_ax(xdata, dwell['TC durations2']['durations'], label='relative criterion', color=color, marker=marker)

        #plotter.set_ylim((49., 55.))

        plotter.set_xticks(xdata)
        plotter.set_xticklabels(dwell['TC durations']['TC'], rotation=45)
        
        ITD = RHTdata['Integrated Durations']
        SD = RHTdata['Sharp Durations']
        IT = RHTdata['Integrated Temperatures']

        plotter.set_ax2()
        plotter.plot_ax(xdata, SD, label="sharp", marker=marker, color=color)
        plotter.plot_ax2(xdata, ITD, label="integrated", marker=marker, color=color)
        plotter.set_ylabel2('Integrated duration (h)')

    plotter.legend(loc='upper left')

    if args.show_plot:
        plotter.show(args)
    else:
        T0T1_str = 'durations_T0_'+str(args.T0)+'_T1_'+str(args.T1)
        plotter.savefig(fig_filename, 'fig:dwell_'+str(dwell_nr+1)+T0T1_str, '_dwell'+str(dwell_nr+1)+T0T1_str+ '.png', args=args, caption='Dwell durations of the fixture according to the individual thermo-couples.')
    #except:
    #    print "Dwell", str(dwell_nr+1), "was not found: I'm not going to plot TC dwell durations"

def block_to_position(block_number, middle=True):

    length=7857.
    totn=80

    onelen = length/totn
    half = onelen/2.
    
    pos = onelen * block_number
    if middle:
        pos += half

    return pos

def plot_TC_IT(RHTdata, args, f_of_position=False, RRR_vs_IT=False, RRR_vs_ITD=False, RRR_vs_SD=False):
    IT = RHTdata['Integrated Temperatures']
    accepted_TC_keys = RHTdata['data_logging']['accepted_TC_keys']

    fig_filename = args.path.replace('.csv','') 


    T0T1text = '$T_0$ = {:0.0f} $^\circ C$'.format(args.T0)
    T0T1text += '\n$T_1$ = {:0.0f} $^\circ C$'.format(args.T1)
    RRR = np.array([306,289,286,266,242,260,247,243,247,236])
    if RRR_vs_ITD:
        plotter.clear((16,10))
        plotter.add_text_to_legend(T0T1text)
        if 'CR114' in fig_filename:
            plotter.set_xlabel('Integrated Duration (h)')
            xdata = [block_to_position(float(key.split(':')[1].split('block ')[1])) for key in accepted_TC_keys]
            ITD = RHTdata['Integrated Durations']
            #marker = plotter.get_marker()
            #color = plotter.get_color()
            IT_df = pd.DataFrame({'xdata':xdata, 'IT':IT, 'ITD':ITD})
            IT_df = IT_df.groupby('xdata').mean().reset_index()
            #plotter.plot_ax(IT_df['xdata'], IT_df['IT']/IT_df['IT'][0], label="TC", marker=marker, color=color)

            #marker = plotter.get_marker()
            #color = plotter.get_color()
            #plotter.plot_ax(IT_df['xdata'], IT_df['ITD']/IT_df['ITD'][0], label='Duration', color=color, marker=marker) 


            #plotter.set_ax2()
            RRRdeg = (354.-RRR)/354. * 100.
            ind = np.array(range(len(RRR)))+1
            blocks = np.array([3,7,13,23,33,43,53,63,73,78])
            ITD_interp = np.interp(block_to_position(blocks), IT_df['xdata'], IT_df['ITD'])
            pos = block_to_position(blocks)
            marker = plotter.get_marker()
            color = plotter.get_color()
            coef, cov = np.polyfit(ITD_interp[:-1], RRRdeg[:-1], 1, cov=True)
            sigma = np.sqrt(cov)
            fit = np.poly1d(coef)
            plotter.plot_ax(ITD_interp, RRRdeg, label="RRR deg.", marker=marker, color=color, linestyle="None")
            plotter.plot_ax(ITD_interp, fit(ITD_interp), label='y=({:0.1f}$\pm${:0.0f})x + ({:0.0f}$\pm${:.0f})'.format(coef[0],sigma[0,0],coef[1],sigma[1,1]), marker="None", color='black', linestyle='-')
            #plotter.text(0.5,0.5, 'y={:0.0f}x{:0.0f}'.format(coef[0],coef[1]), transform=plotter.ax.transAxes)
            plotter.set_ylabel('RRR degradation (%)')

            plotter.legend(loc='best')
            #plotter.set_ylim((49., 55.))
        else:
            return

        fig_filename += "RRR_vs_ITD"
 
    elif RRR_vs_IT:
        plotter.clear((16,10))
        plotter.add_text_to_legend(T0T1text)
        if 'CR114' in fig_filename:
            plotter.set_xlabel('Integrated Temperature')
            xdata = [block_to_position(float(key.split(':')[1].split('block ')[1])) for key in accepted_TC_keys]
            ITD = RHTdata['Integrated Durations']
            #marker = plotter.get_marker()
            #color = plotter.get_color()
            IT_df = pd.DataFrame({'xdata':xdata, 'IT':IT, 'ITD':ITD})
            IT_df = IT_df.groupby('xdata').mean().reset_index()
            #plotter.plot_ax(IT_df['xdata'], IT_df['IT']/IT_df['IT'][0], label="TC", marker=marker, color=color)

            #marker = plotter.get_marker()
            #color = plotter.get_color()
            #plotter.plot_ax(IT_df['xdata'], IT_df['ITD']/IT_df['ITD'][0], label='Duration', color=color, marker=marker) 


            #plotter.set_ax2()
            RRRdeg = (354.-RRR)/354. * 100.
            ind = np.array(range(len(RRR)))+1
            blocks = np.array([3,7,13,23,33,43,53,63,73,78])
            IT_interp = np.interp(block_to_position(blocks), IT_df['xdata'], IT_df['IT'])
            pos = block_to_position(blocks)
            marker = plotter.get_marker()
            color = plotter.get_color()
            coef, cov = np.polyfit(IT_interp[:-1], RRRdeg[:-1], 1, cov=True)
            sigma = np.sqrt(cov)
            fit = np.poly1d(coef)
            plotter.plot_ax(IT_interp, RRRdeg, label="RRR deg.", marker=marker, color=color, linestyle="None")
            plotter.plot_ax(IT_interp, fit(IT_interp), label='y=({:0.1f}$\pm${:0.0f})x + ({:0.0f}$\pm${:.0f})'.format(coef[0],sigma[0,0],coef[1],sigma[1,1]), marker="None", color='black', linestyle='-')
            #plotter.text(0.5,0.5, 'y={:0.0f}x{:0.0f}'.format(coef[0],coef[1]), transform=plotter.ax.transAxes)
            plotter.set_ylabel('RRR degradation (%)')

            plotter.legend(loc='best')
        else:
            return
        fig_filename += "RRR_vs_IT"

    elif RRR_vs_SD:
        plotter.clear((16,10))
        plotter.add_text_to_legend(T0T1text)
        if 'CR114' in fig_filename:
            plotter.set_xlabel('Sharp Duration')
            xdata = [block_to_position(float(key.split(':')[1].split('block ')[1])) for key in accepted_TC_keys]
            SD = RHTdata['Sharp Durations']
            #marker = plotter.get_marker()
            #color = plotter.get_color()
            IT_df = pd.DataFrame({'xdata':xdata, 'IT':IT, 'SD':SD})
            IT_df = IT_df.groupby('xdata').mean().reset_index()
            #plotter.plot_ax(IT_df['xdata'], IT_df['IT']/IT_df['IT'][0], label="TC", marker=marker, color=color)

            #marker = plotter.get_marker()
            #color = plotter.get_color()
            #plotter.plot_ax(IT_df['xdata'], IT_df['ITD']/IT_df['ITD'][0], label='Duration', color=color, marker=marker) 


            #plotter.set_ax2()
            RRRdeg = (354.-RRR)/354. * 100.
            ind = np.array(range(len(RRR)))+1
            blocks = np.array([3,7,13,23,33,43,53,63,73,78])
            SD_interp = np.interp(block_to_position(blocks), IT_df['xdata'], IT_df['SD'])
            pos = block_to_position(blocks)
            marker = plotter.get_marker()
            color = plotter.get_color()
            coef, cov = np.polyfit(SD_interp[:-1], RRRdeg[:-1], 1, cov=True)
            sigma = np.sqrt(cov)
            fit = np.poly1d(coef)
            plotter.plot_ax(SD_interp, RRRdeg, label="RRR deg.", marker=marker, color=color, linestyle="None")
            plotter.plot_ax(SD_interp, fit(SD_interp), label='y=({:0.1f}$\pm${:0.0f})x + ({:0.0f}$\pm${:.0f})'.format(coef[0],sigma[0,0],coef[1],sigma[1,1]), marker="None", color='black', linestyle='-')
            #plotter.text(0.5,0.5, 'y={:0.0f}x{:0.0f}'.format(coef[0],coef[1]), transform=plotter.ax.transAxes)
            plotter.set_ylabel('RRR degradation (%)')

            plotter.legend(loc='best')

            #plotter.set_ylim((49., 55.))
        else:
            return

        fig_filename += "RRR_vs_SD"

    elif f_of_position:
        plotter.clear((16,10))
        plotter.add_text_to_legend(T0T1text)
        plotter.set_xlabel('Longitudinal position(m)')
        plotter.set_ylabel('Normalized Integrated')
        xdata = [block_to_position(float(key.split(':')[1].split('block ')[1])) for key in accepted_TC_keys]
        marker = plotter.get_marker()
        color = plotter.get_color()
        plotter.plot_ax(xdata, (IT-args.T0)/(IT[0]-args.T0), label="Temperature $- T_0$", marker=marker, color=color)

        marker = plotter.get_marker()
        color = plotter.get_color()
        ITD = RHTdata['Integrated Durations']
        plotter.plot_ax(xdata, ITD/ITD[0], label='Duration', color=color, marker=marker) 

        if 'CR114' in fig_filename:
            plotter.set_ax2()
            RRRdeg = (354.-RRR)/354. * 100.
            ind = np.array(range(len(RRR)))+1
            blocks = np.array([3,7,13,23,33,43,53,63,73,78])
            pos = block_to_position(blocks)
            marker = plotter.get_marker()
            color = plotter.get_color()
            plotter.plot_ax2(pos, RRRdeg, label="RRR deg.", marker=marker, color=color)
            plotter.set_ylabel2('RRR degradation (%)')

        plotter.legend(loc='upper left')
        #plotter.set_ylim((49., 55.))

        fig_filename += "fofpos"
    else:
        plotter.add_text_to_legend(T0T1text)
        plotter.set_xlabel('TC')
        plotter.set_ylabel('Integrated Temperature')
        xdata = range(len(accepted_TC_keys))
        plotter.plot_ax(xdata, IT, label="TC")

        #plotter.set_ylim((49., 55.))

        plotter.set_xticks(xdata)
        plotter.set_xticklabels(accepted_TC_keys, rotation=45)

        plotter.legend(loc='best')

    #plotter.ax.set_xlim((0.,dwells[-1]['hours'].max()+120.))


    if args.show_plot:
        plotter.show(args)
    else:
        T0T1_str = '_T0_{:0.0f}'.format(args.T0)+'_T1_{:0.0f}'.format(args.T1)
        plotter.savefig(fig_filename, 'fig:TC_ITs', 'TC_ITs' + T0T1_str + '.png', args=args, caption='Integrated temperature of the fixture according to the individual thermo-couples.')


def get_block_temperatures(logging_df, block_numbers, accepted_keys):
    block_temperatures={}
    for block_n in block_numbers:
        block_str = 'block ' + str(block_n)
        block_keys = []
        for key in accepted_keys:
            if block_str in key:
                block_keys.append(key)
        if len(block_keys) != 0:
            block_temperatures[block_n] = logging_df[block_keys]
    return block_temperatures

def plot_map(RHTdata, args, field='Temperature'):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    logging_df = logging_df[logging_df['hours']<350]
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    TC_mapping = RHTdata['TC_mapping']
    block_mapping = RHTdata['block_mapping']
    keys = logging['accepted_TC_keys']
    block_numbers = sorted(list(set([int(key.split('block')[1].split(',')[0]) for key in block_mapping if 'block' in key])))

    if field == 'Temperature':
        caption='The temperature according to the accepted thermo-couples as a function of time and fixture fixture block number.'
        hours_samples, block_samples = np.meshgrid(logging_df['hours'], block_numbers)
        block_temperatures = get_block_temperatures(logging_df, block_numbers, keys)

        block_field_list = []
        for j, block_n in enumerate(block_numbers):
            meanT = block_temperatures[block_n].mean(axis=1).values 
            block_field_list.append(meanT)

        block_field_samples = np.array(block_field_list)

        plotter.pcolormesh(hours_samples, block_samples, block_field_samples, cmap='coolwarm', colorbar_label='T($\degree$C)')

        plotter.plot_dwells(dwells, only_txt=True, vertical_position=0.4)
        # set the limits of the plot to the limits of the data
        plotter.set_xlabel('Time (h)')
        plotter.set_ylabel('Block number')
    elif field == 'middevT':
        caption='The mid-range temperature deviation according to the accepted thermo-couples as a function of time and fixture block number.'
        hours_samples, block_samples = np.meshgrid(logging_df['hours'], block_numbers)
        block_temperatures = get_block_temperatures(logging_df, block_numbers, keys)

        block_field_list = []
        for j, block_n in enumerate(block_numbers):
            meanT = block_temperatures[block_n].mean(axis=1).values 
            middevT = meanT - logging_df['Tmid']
            block_field_list.append(middevT)

        block_field_samples = np.array(block_field_list)

        plotter.pcolormesh(hours_samples, block_samples, block_field_samples, cmap='coolwarm', colorbar_label='T - mid(T) ($\degree$C)')

        plotter.plot_dwells(dwells, only_txt=True, vertical_position=0.4)
        # set the limits of the plot to the limits of the data
        plotter.set_xlabel('Time (h)')
        plotter.set_ylabel('Block number')
    elif field == 'middevT_dwells':
        caption='The mid-range deviation of the accepted thermo-couples in the dwells as a function of time and fixture block number.'
        for i,dwell in enumerate(dwells):
            dwell_df = dwell['DataFrame']

            hours_samples, block_samples = np.meshgrid(dwell_df['hours'], block_numbers)
            block_temperatures = get_block_temperatures(dwell_df, block_numbers, keys)

            block_field_list = []
            for j, block_n in enumerate(block_numbers):
                meanT = block_temperatures[block_n].mean(axis=1).values 
                middevT = meanT - dwell_df['Tmid']
                block_field_list.append(middevT)

            plotter.ax.set_xlim((dwells[0]['DataFrame']['hours'].min(),dwells[-1]['DataFrame']['hours'].max()))


            try:
                block_field_samples = np.array(block_field_list)

                if i==0:
                    plotter.pcolormesh(hours_samples, block_samples, block_field_samples, cmap='coolwarm', colorbar_label='T - mid(T) ($\degree$C)')
                else:
                    plotter.pcolormesh(hours_samples, block_samples, block_field_samples, cmap='coolwarm')
            except:
                pass
    elif field == 'block_homogeneity':
        caption='Block-wise homogeneity as a function of time and fixture block number.'
        hours_samples, block_samples = np.meshgrid(logging_df['hours'], block_numbers)
        block_temperatures = get_block_temperatures(logging_df, block_numbers, keys)

        block_field_list = []
        for j, block_n in enumerate(block_numbers):
            meanT = block_temperatures[block_n].mean(axis=1).values 
            minT = block_temperatures[block_n].min(axis=1).values 
            maxT = block_temperatures[block_n].max(axis=1).values 
            hper2 = (maxT - minT)/2.
            block_field_list.append(hper2)

        block_field_samples = np.array(block_field_list)

        plotter.pcolormesh(hours_samples, block_samples, block_field_samples, cmap='coolwarm', colorbar_label='H/2 ($\degree$C)')

        plotter.plot_dwells(dwells, only_txt=True, vertical_position=0.4)
        # set the limits of the plot to the limits of the data
        plotter.set_xlabel('Time (h)')
        plotter.set_ylabel('Block number')
    elif field == 'block_homogeneity_dwells':
        caption='Block-wise homogeneity for each dwell as a function of time and fixture block number.'
        for i,dwell in enumerate(dwells):
            dwell_df = dwell['DataFrame']

            hours_samples, block_samples = np.meshgrid(dwell_df['hours'], block_numbers)
            block_temperatures = get_block_temperatures(dwell_df, block_numbers, keys)

            block_field_list = []
            for j, block_n in enumerate(block_numbers):
                meanT = block_temperatures[block_n].mean(axis=1).values 
                minT = block_temperatures[block_n].min(axis=1).values 
                maxT = block_temperatures[block_n].max(axis=1).values 
                hper2 = (maxT - minT)/2.
                block_field_list.append(hper2)

            block_field_samples = np.array(block_field_list)

            if i==0:
                plotter.pcolormesh(hours_samples, block_samples, block_field_samples, cmap='coolwarm', colorbar_label='H/2 ($\degree$C)')
            else:
                plotter.pcolormesh(hours_samples, block_samples, block_field_samples, cmap='coolwarm')
 

    plotter.plot_dwells(dwells, only_txt=True, vertical_position=0.4)
    if not (field == 'block_homogeneity_dwells' or field == 'middevT_dwells'):
        plotter.plot_onlines(RHTdata, plot_curves=False)
    # set the limits of the plot to the limits of the data
    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Block number')

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:'+field+'-map', '_' + field + '-map_' + parameters_str(args) + '.png', args=args, caption=caption)

def plot(RHTdata, args):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    plotter.plot_ax(program_df['hours from'],program_df['From Tp zone B3'], label='Program')

    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Temperature ($\degree$C)')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmin'], label='min(T)')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmean'], label='mean(T)')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmid'], label='mid(T)')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmax'], label='max(T)')
    plotter.set_lim_args(args)

    plotter.plot_dwells(dwells)
    plotter.plot_onlines(RHTdata)
    plotter.write_dwell_notes(args)
    plotter.write_tc_notes(RHTdata, rejected=True)

    plotter.legend(loc='best')

    #plotter.ax.set_xlim((0.,dwells[-1]['hours'].max()+120.))

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        caption_text = 'Temperature as a function of time. Program is the initial control sequence for the furnace that is defined apriori.'
        #if RHTdata['onlines'] > 0: caption_text += ' Online $i$ (if any) is the $i^{th}$ change to the program during the heat treatment cycle.'
        plotter.savefig(fig_filename, 'fig:dwell_plot', '_' + parameters_str(args) + '.png', args=args, caption=caption_text)

def plot_mean_and_theoretical(RHTdata, args, theoretical=True):
    plotter.clear((16,10))
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    #plotter.plot_ax(program_df['hours from'],program_df['From Tp zone B3'], label='Program')

    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Temperature ($\degree$C)')
    #plotter.insert_color('black')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmax'], label='Maximum')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmin'], label='Minimum')

    plotter.set_lim_args(args)

    if theoretical:
        x1 = 210./25.
        x2 = x1 + 48.
        x3 = x2 + (400.-210.)/50.
        x4 = x3 + 48.
        x5 = x4 + (665.-400.)/50.
        x6 = x5 + 50.
        x7 = x6 + 665./50.
        xtheor = np.array([0.,x1,x2,x3,x4,x5,x6,x7])
        ytheor = np.array([0.,210.,210.,400.,400.,665.,665., 0.])
        plotter.plot_ax(xtheor+40.,ytheor, linestyle='--', label='Theoretical')
        plotter.set_ylim((0.,700.))


    #plotter.plot_dwells(dwells)
    #plotter.plot_onlines(RHTdata)
    #plotter.write_dwell_notes(args)
    #plotter.write_tc_notes(RHTdata, rejected=True)

    plotter.legend(loc='best')

    #plotter.ax.set_xlim((0.,dwells[-1]['hours'].max()+120.))

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:mean_theoretical_plot', 'mean_theoretical_plot_' + parameters_str(args) + '.png', args=args, caption='Dwell plot')

def plot_dwell_close_up(RHTdata, args, dwellnr = 1):
    plotter.clear((16,10))
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    #plotter.plot_ax(program_df['hours from'],program_df['From Tp zone B3'], label='Program')

    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Temperature ($\degree$C)')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmax'], label='Maximum')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmin'], label='Minimum')

    dwell = dwells[dwellnr-1]
    dwell_df = dwell['DataFrame']
    xargs_old = plotter.ax.get_xlim()
    yargs_old = plotter.ax.get_ylim()
    args.xlim = (dwell_df['hours'].iloc[0]-10, dwell_df['hours'].iloc[-1]+10)
    yran = args.dwell_target_ranges[dwellnr-1]
    args.ylim = (yran[0] - 5, yran[1] + 5)
    plotter.set_lim_args(args)

    plotter.plot_dwells(dwells, no_txt=True)
    plotter.plot_allowed_band(dwells)

    #plotter.plot_onlines(RHTdata)
    #plotter.write_dwell_notes(args)
    #plotter.write_tc_notes(RHTdata, rejected=True)

    plotter.legend(loc='best')

    #plotter.ax.set_xlim((0.,dwells[-1]['hours'].max()+120.))

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:dwell_' + str(dwellnr) + 'close_up_plot', 'dwell_' + str(dwellnr) + 'close_up_plot_' + parameters_str(args) + '.png', args=args, caption='Dwell plot')

    args.xlim = xargs_old 
    args.ylim = yargs_old 

def plot_heater_power(RHTdata, args):
    logging = RHTdata['data_logging']
    logging_df = logging['DataFrame']
    program_df = RHTdata['program']['DataFrame']
    dwells = RHTdata['dwells']

    plotter.set_xlabel('Time (h)')
    plotter.set_ylabel('Temperature ($\degree$C)')
    plotter.plot_ax(logging_df['hours'],logging_df['Tmid'], label='mid(T)')
    plotter.set_ax2()
    plotter.set_ylabel2('Heater power (%)')
    plotter.plot_ax2(logging_df['hours'],logging_df['OP zone +A1'], label='OP zone +A1')
    plotter.plot_ax2(logging_df['hours'],logging_df['OP zone +B1'], label='OP zone +B1')
    plotter.set_lim_args(args)

    plotter.plot_dwells(dwells)
    plotter.plot_onlines(RHTdata, plot_curves=False)
    plotter.write_dwell_notes(args)
    plotter.write_tc_notes(RHTdata, rejected=True)

    plotter.legend(loc='best')

    #plotter.ax.set_xlim((0.,dwells[-1]['hours'].max()+120.))

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:heater_power', '_heater_power_' + parameters_str(args) + '.png', args=args, caption='heater power as a function of time.')

def plot_dwell_summary(RHTdatas, n, args, caption='None'):
    plotter.set_xlabel('Coil ID')
    plotter.set_ylabel('Temperature ($\degree$C)')

    caption='Dwell {} asymptotic temperature.'.format(n)
    data = []
    labels = []
    nof_accepted_coil_ids = 0
    for i, RHTdata in enumerate(RHTdatas):
        dwells = RHTdata['dwells']
        dwell = fetch_dwell_by_number(dwells, n)
        if not dwell == None and dwell['duration'] >= 10:
            dwell_df = dwell['DataFrame']
            accepted_TC_keys = RHTdata['data_logging']['accepted_TC_keys']
            dwell_asymptot = dwell_df[dwell_df['hours'] >= dwell_df['hours'].max()-2]
            dwell_asymptot = dwell_asymptot[dwell_asymptot['hours'] <= dwell_asymptot['hours'].max()-1]
            values = dwell_asymptot[accepted_TC_keys].values.flatten()
            if not any(np.isnan(values)):
                nof_accepted_coil_ids += 1
                data.append(values)
                labels.append(RHTdata['Coil ID'])
                if RHTdata['Coil ID'] == 'CR110':
                        plotter.axvline(nof_accepted_coil_ids-.5)

    plotter.boxplot(data, labels=labels)
    boxplot_data = plotter.plots[-1]
    #boxplot_keys = ['boxes', 'fliers', 'medians', 'means', 'whiskers', 'caps']
    boxplot_keys = boxplot_data.keys()
    boxplot_numbers_dict = {}
    boxplot_keys_nonempty = []
    for boxplot_key in boxplot_keys:
        if len(boxplot_data[boxplot_key]) > 0:
            if 'whiskers' == boxplot_key or 'caps' == boxplot_key:
                boxplot_numbers_dict[boxplot_key] = []
                boxplot_keys_nonempty.append(boxplot_key)
                for i in range(0,len(boxplot_data[boxplot_key]),2):
                    line1 = boxplot_data[boxplot_key][i]
                    line2 = boxplot_data[boxplot_key][i+1]
                    ymax = np.around(np.max([line1.get_ydata(),line2.get_ydata()]), 1)
                    ymin = np.around(np.min([line1.get_ydata(),line2.get_ydata()]), 1)
                    boxplot_numbers_dict[boxplot_key].append(np.array((ymin,ymax)))
            else:
                boxplot_numbers_dict[boxplot_key] = []
                boxplot_keys_nonempty.append(boxplot_key)
                for line in boxplot_data[boxplot_key]:
                    ydata = line.get_ydata()
                    try:
                        ymax = np.around(np.max(ydata), 1)
                    except:
                        ymax = None
                    try:
                        ymin = np.around(np.min(ydata), 1)
                    except:
                        ymin = None
 
                    boxplot_numbers_dict[boxplot_key].append(np.array((ymin,ymax)))

    boxplot_table_keys = list(boxplot_keys_nonempty)
#    try:
#        boxplot_table_keys.remove('caps')
#        boxplot_table_keys.remove('fliers')
#    except:
#        pass

    boxplot_numbers_dict['Coil ID'] = labels

    boxplot_numbers_df = pd.DataFrame(boxplot_numbers_dict)

    report.store_table(to_math(boxplot_numbers_df[['Coil ID'] + boxplot_table_keys].to_latex(index=False, header=True, float_format="{:0.1f}".format)), 'table:dwell boxplot data '+str(n), caption='Dwell '+str(n)+' boxplot data', resize_textwidth=True)

    ymin, ymax = args.dwell_target_ranges[n-1]
    ran = 10.
    plotter.set_ylim((ymin, ymin+2*ran))

    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:boxplot dwell '+str(n), '_boxplot_' + parameters_str(args) + '.png', args=args, caption=caption)

def plot_TC_IT_summary(RHTdatas, args, caption='None'):

    caption='Integrated weighted temperature of the RHT.'

    plotter.set_xlabel('TC')
    plotter.set_ylabel('Normalized Integrated Temperature')

    all_key_lists = [data['data_logging']['accepted_TC_keys'] for data in RHTdatas]
    all_keys = set([key for key_list in all_key_lists for key in key_list])
    all_keys_sorted = sort_list_by_block_number(all_keys)
    xticks = range(len(all_keys_sorted))
    plotter.set_xticks(xticks)
    plotter.set_xticklabels(all_keys_sorted, rotation=45)

    for i, RHTdata in enumerate(RHTdatas):
        if not "003_1" in RHTdata['path']:
            try:
                accepted_TC_keys = RHTdata['data_logging']['accepted_TC_keys']
                IT = RHTdata['Integrated Temperatures']
                xdata = [all_keys_sorted.index(key) for key in accepted_TC_keys]

                plt_data = np.array([xdata,IT]).T
                plt_data = plt_data[plt_data[:,0].argsort()].T

                #xdata = range(len(accepted_TC_keys))
                marker = plotter.get_marker()
                color = plotter.get_color()
                plotter.plot_ax(plt_data[0], plt_data[1], color=color, marker=marker, label=RHTdata['path'].split('.')[0])

                #plotter.set_ylim((49., 55.))
            except:
                print "RHTdata not found", i
                pass

    plotter.legend(loc='best')
    if args.show_plot:
        plotter.show(args)
    else:
        fig_filename = args.path.replace('.csv','') 
        plotter.savefig(fig_filename, 'fig:TC_ITs_comparison', 'TC_ITs_comparison.png', args=args, caption='Integrated temperature of the fixture according to the individual thermo-couples.')

class RHTPrompt(Cmd):
    prompt = 'RHT> '
    intro  = "Welcome to RHT command line interface"

    def do_load(self, inp):
        RHT_csv_reader = RHT_CSV_Reader()
        self.RHTdata = RHT_csv_reader.read_RHT_file(args, args.path, False)

    def help_load(self):
        print "Load the data file that is defined with RHT command"

    def do_exit(self, inp):
        print "Exiting..."
        return True

    def do_q(self, inp):
        print "Exiting..."
        return True

    def do_xlim(self, inp):
        print "Setting plot xlim:", inp
        try:
            words = inp.split()
            if len(words) == 2:
                args.xlim = [float(s) for s in words]
            else:
                print "It didn't work because you didn't give me 2 values..."
        except:
            print "command failed!"

    def help_xlim(self):
        print "Set plot x-axis limits: min max"

    def do_ylim(self, inp):
        print "Setting plot ylim:", inp
        try:
            words = inp.split()
            if len(words) == 2:
                args.ylim = [float(s) for s in words]
            else:
                print "It didn't work because you didn't give me 2 values..."
        except:
            print "command failed!"

    def help_ylim(self):
        print "Set plot y-axis limits: min max"

    def do_tdf(self, inp):
        print "Setting temperature deviation filters:", inp
        try:
            args.temperature_deviation_filters = [float(s) for s in inp.split()]
        except:
            print "command failed!"

    def help_tdf(self):
        print "Set temperature deviation filters (as many as needed): first_filter second_filter ..."

    def do_dt(self, inp):
        print "Setting dwell target temperatures:", inp
        try:
            args.dwell_target_temperatures = [float(s) for s in inp.split()]
        except:
            print "command failed!"

    def help_dt(self):
        print "Set dwell target temperature: T_first_dwell T_second_dwell ..."

    def do_ddmin(self, inp):
        print "Setting minimum dwell duration:", inp
        try:
            args.dwell_duration_minimum = float(inp)
        except:
            print "command failed!"

    def help_ddmin(self):
        print "Set minimum dwell duration (if program plateaus are used as dwell targets)."

    def do_dtdev(self, inp):
        print "Setting dwell target deviation:", inp
        try:
            args.dwell_target_deviation = float(inp)
        except:
            print "command failed!"

    def help_dtdev(self):
        print "Set dwell target deviation."

    def do_dthom(self, inp):
        print "Setting dwell target homogeneity:", inp
        try:
            args.dwell_target_homogeneity = float(inp)
        except:
            print "command failed!"

    def help_dthom(self):
        print "Set dwell homogeneity tolerance."

    def do_dthomhalf(self, inp):
        print "Setting dwell target homogeneity half band:", inp
        try:
            args.dwell_target_homogeneity_half_band = float(inp)
        except:
            print "command failed!"

    def help_dthomhalf(self):
        print "Set dwell homogeneity tolerance half band."

    def do_dhtol(self, inp):
        print "Setting dwell heat rate tolerance:", inp
        try:
            args.dwell_heat_rate_tolerance = float(inp)
        except:
            print "command failed!"

    def help_dhtol(self):
        print "Set dwell heat rate tolerance."
     
    def do_plot_accepted_TC(self, inp):
        plot_accepted_TC(self.RHTdata, args)

    def help_plot_accepted_TC(self):
        print "Plot the accepted thermo-couples."

    def do_plot_homogeneity(self, inp):
        if not hasattr(self, 'RHTdata'): 
            RHT_csv_reader = RHT_CSV_Reader()
            self.RHTdata = RHT_csv_reader.read_RHT_file(args, args.path, False)
        regenerate_online_data(self.RHTdata)
        analyze(self.RHTdata, args)
        plot_homogeneity(self.RHTdata, args)

    def help_plot_homogeneity(self):
        print "Plot the homogeneity of accepted thermo-couples."

    def do_plot_Ar(self, inp):
        if not hasattr(self, 'RHTdata'): 
            RHT_csv_reader = RHT_CSV_Reader()
            self.RHTdata = RHT_csv_reader.read_RHT_file(args, args.path, False)
        regenerate_online_data(self.RHTdata)
        analyze(self.RHTdata, args)
        plot_Ar(self.RHTdata, args)

    def help_plot_Ar(self):
        print "Plot the Ar flows in the tooling and retort."


    def do_plot_all_TC(self, inp):
        if not hasattr(self, 'RHTdata'): 
            RHT_csv_reader = RHT_CSV_Reader()
            self.RHTdata = RHT_csv_reader.read_RHT_file(args, args.path, False)
        regenerate_online_data(self.RHTdata)
        analyze(self.RHTdata, args)
        plot_all_TC(self.RHTdata, args)

    def help_plot_all_TC(self):
        print "Plot all thermo-couples."

    def do_plot(self, inp):
        if not hasattr(self, 'RHTdata'): 
            RHT_csv_reader = RHT_CSV_Reader()
            self.RHTdata = RHT_csv_reader.read_RHT_file(args, args.path, False)
        regenerate_online_data(self.RHTdata)
        analyze(self.RHTdata, args)
        plot_all_TC(self.RHTdata, args)
        plot_accepted_TC(self.RHTdata, args)
        plot(self.RHTdata, args)

    def help_plot(self):
        print "Plot all thermo-couples, plot accepted thermo-couples and plot dwells."

    def do_plot(self, inp):
        if not hasattr(self, 'RHTdata'): 
            RHT_csv_reader = RHT_CSV_Reader()
            self.RHTdata = RHT_csv_reader.read_RHT_file(args, args.path, False)
        regenerate_online_data(self.RHTdata)
        analyze(self.RHTdata, args)
        plot(self.RHTdata, args)

    def help_plot(self):
        print "Plot only the dwell plot."

    def do_print_dwells(self, inp):
        if not hasattr(self, 'RHTdata'): 
            RHT_csv_reader = RHT_CSV_Reader()
            self.RHTdata = RHT_csv_reader.read_RHT_file(args, args.path, False)
        print_dwells(self.RHTdata, args)

    def help_print_dwells(self):
        print "Print dwell information."

    def do_analyze(self, inp):
        if not hasattr(self, 'RHTdata'): 
            RHT_csv_reader = RHT_CSV_Reader()
            self.RHTdata = RHT_csv_reader.read_RHT_file(args, args.path, False)
        analyze(self.RHTdata, args)

    def help_analyze(self):
        print "Analyze the loaded data."

    def do_parameters(self, inp):
        try:
            print "dtdev = dwell target deviation"
            print "dthom = dwell target homogeneity"
            print "dthomhalf = dwell target homogeneity half band"
            print "dhtol = dwell heat_rate tolerance"
            print "dtdev\tdthom\tdthomhalf\tdhtol"
            print "{}\t{}\t{}\t{}".format(args.dwell_target_deviation, args.dwell_target_homogeneity, args.dwell_target_homogeneity_half_band, args.dwell_heat_rate_tolerance)
        except:
            print "command failed!"

    def help_parameters(self):
        print "Print all active parameters"

    def do_set_show_plot(self, inp):
        if inp.lower()=='true':
            print "Setting show plot on"
            args.show_plot = True
        elif inp.lower()=='false':
            print "Setting show plot off"
            args.show_plot = False
        else:
            print "Usage: set_savefig True/False"

    def help_set_show_plot(self, inp):
        print "Setting show plot on/off (and savefig off/on)"

def parse_target_ranges(args):
    try:
        rs = []
        for r in args.dwell_target_ranges:
            rs.append([float(s) for s in r.split(' ')])
        args.dwell_target_ranges = rs
    except:
        print "failed to parse --dwell-target-ranges."

def RHTdata_pickle_analysed(RHTdata):
    basename = os.path.splitext(RHTdata['path'])[0]
    pickle_path = basename +'_analyzed.pickle'
    print "Let's dump the pickle", pickle_path
    cpickle_dump(RHTdata, pickle_path)

def dwell_pickle_analysed(dwells):
    basename = os.path.splitext(RHTdata['path'])[0]
    pickle_path = basename +'_dwells_analyzed.pickle'
    cpickle_dump(RHTdata, pickle_path)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Plot mtbop strain data')
    parser.add_argument('path', type=str)
    parser.add_argument('-v', '--variables', nargs='?', type=str)
    parser.add_argument('-x', '--x-axis', type=str)
    parser.add_argument('-y', '--y-axis', nargs='+', type=str)
    parser.add_argument('--xlim', nargs=2, type=float, default=[0,350])
    parser.add_argument('--ylim', nargs=2, type=float)
    parser.add_argument('-tdf', '--temperature-deviation-filters', nargs='+', type=float, default=[500,70,50])
    parser.add_argument('-dtr', '--dwell-target-ranges', nargs='+', type=str, default=['204 216','389 401','660 670'])
    parser.add_argument('-ntr', '--no-target-ranges', action='store_true', default=False)
    parser.add_argument('-dt', '--dwell-target-temperatures', nargs='+', type=float, default=[210.,395.,665.])
    parser.add_argument('-ddmin', '--dwell-duration-minimum', type=float)
    parser.add_argument('-dtdev', '--dwell-target-deviation', type=float, nargs='+')
    #parser.add_argument('-dmidev', '--dwell-mid-deviation', type=float, default=None, nargs='+')
    parser.add_argument('-dmidev', '--dwell-mid-deviation', type=float, default=None)
    parser.add_argument('-dthom', '--dwell-target-homogeneity', type=float)#, default=5.)
    parser.add_argument('-dthomhalf', '--dwell-target-homogeneity-half-band', type=float, nargs='+')
    parser.add_argument('-dhtol', '--dwell-heat-rate-tolerance', type=float, default=0.02)
    parser.add_argument('-lv', '--list-variables', action='store_true', default=False) 
    parser.add_argument('-sp', '--show-plot', action='store_true', default=False) 
    parser.add_argument('-cli', '--command-line', action='store_true', default=False) 
    parser.add_argument('-m', '--thermo-couple-mapping', type=str, default='default.mapping') 
    parser.add_argument('-ni', '--no-images', action='store_true', default=False) 
    parser.add_argument('-o', '--override-pickle', action='store_true', default=False) 
    parser.add_argument('-tcal', '--thermo-couple-calibration', type=str) 
    parser.add_argument('-comp', '--compare-analyses', action='store_true', default=False) 
    parser.add_argument('--no-report', action='store_true', default=False) 
    parser.add_argument('--minimum-dwell-duration', type=float, default=10.)
    parser.add_argument('--dwell-close-ups', action='store_true', default=False) 
    parser.add_argument('--no-clock-change-detection', action='store_true', default=False) 
    parser.add_argument('--only-durations', action='store_true', default=False) 
    parser.add_argument('--T0', type=float, default=400.) 
    parser.add_argument('--T1', type=float, default=665.) 

    global args 
    args = parser.parse_args()
    path = args.path
    
    file_logger = Logger(path)
    report = Report(path + '.tex', 'hllhcedms_template_short.tex')

    parse_target_ranges(args)

    if type(args.dwell_target_homogeneity_half_band) == type([]):
        dthomhalfs = args.dwell_target_homogeneity_half_band
    else:
        dthomhalfs = [args.dwell_target_homogeneity_half_band]

    if type(args.dwell_target_deviation) == type([]):
        dtdevs = args.dwell_target_deviation
    else:
        dtdevs = [args.dwell_target_deviation]

    if args.command_line:
        RHTPrompt().cmdloop()
    else:
        RHT_csv_reader = RHT_CSV_Reader()
        read_RHT_file = RHT_csv_reader.read_RHT_file
        RHTdata = read_RHT_file(args, path, args.override_pickle)
        for args.dwell_target_deviation in dtdevs:
            for args.dwell_target_homogeneity_half_band in dthomhalfs:
                regenerate_online_data(RHTdata)
                analyze(RHTdata, args)
                if args.only_durations:
                    plot_mean_and_theoretical(RHTdata, args)
                    plot_TC_dwell_durations(RHTdata, args)
                    plot_TC_IT(RHTdata, args)
                    plot_TC_dwell_durations(RHTdata, args, f_of_position=True)
                    plot_TC_IT(RHTdata, args, f_of_position=True)
                    plot_TC_IT(RHTdata, args, RRR_vs_IT = True)
                    plot_TC_IT(RHTdata, args, RRR_vs_ITD = True)
                    plot_TC_IT(RHTdata, args, RRR_vs_SD = True)
                    exit()
                if not args.no_images:
                    plot_mean_and_theoretical(RHTdata, args)
                    plot_all_TC(RHTdata, args)
                    plot_accepted_TC(RHTdata, args)
                    plot(RHTdata, args)
                    plot_homogeneity(RHTdata, args)
                    plot_Ar(RHTdata, args)
                    plot_heating_rate(RHTdata, args)
                    plot_map(RHTdata, args, field='Temperature')
                    plot_map(RHTdata, args, field='middevT')
                    plot_map(RHTdata, args, field='middevT_dwells')
                    plot_map(RHTdata, args, field='block_homogeneity')
                    plot_map(RHTdata, args, field='block_homogeneity_dwells')
                    try:
                        plot_TC_dwell_durations(RHTdata, args)
                        plot_TC_IT(RHTdata, args)
                        plot_TC_dwell_durations(RHTdata, args, f_of_position=True)
                        plot_TC_IT(RHTdata, args, f_of_position=True)
                        plot_TC_IT(RHTdata, args, RRR_vs_IT = True)
                        plot_TC_IT(RHTdata, args, RRR_vs_ITD = True)
                    except:
                        pass
                    plot_heater_power(RHTdata, args)
                    if args.dwell_close_ups:
                        for i,_ in enumerate(RHTdata['dwells']):
                            plot_dwell_close_up(RHTdata, args, i+1)

                plotter.reset()

    if not args.no_report:
        try:
            if args.compare_analyses:
                report.compare_analyses(RHTdata, args)
            report.write_report(RHTdata)
            report.close()
            report.compile()
            file_logger.close()
        except:
            pass
    RHTdata_pickle_analysed(RHTdata)
        #dwell_pickle_analysed(RHTdata)


   

